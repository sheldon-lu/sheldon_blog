<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python_问题小结(2)]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2FPython-%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93-2%2F</url>
    <content type="text"><![CDATA[环境：未特别注明的话，均为Python 3.6.5，IDE：VS code 遇到的都是基础问题，分了两篇。 担心一篇写多了会看不下去 『1』关于python无法显示中文的问题：SyntaxError: Non-ASCII character ‘\xe4’ in file test.py on line 3, but no encoding declared。python：2.7.15 解决办法： 在以后的每一个需要显示汉字的python文件中， 可以采用如下方法在 #!/usr/bin/python的下一行加上一句话来定义编码格式， 我以utf-8编码为例。 1234567891011### 第一种：#!/usr/bin/python#coding:utf-8### 第二种：#!/usr/bin/python#-*-coding:utf-8 -*-### 第三种：#!/usr/bin/python#vim: set fileencoding:utf-8 『2』有时候在去数据的时候会遇到数据内有中文，但是取出来的是unicode码，用了很多方法也转不了中文解决: “反编码”我自己起的名字，大概意思就是我得到一串字符，是unicode码，如：‘\u53eb\u6211’，进行反编码后得到其对应的汉字。 123f='\u53eb\u6211'print fprint(f.decode('unicode-escape'))123 结果为: 12\u53eb\u6211 叫我 『3』在编译时会出现这样的错：IndentationError:expected an indented block说明此处需要缩进，你只要在出现错误的那一行，按空格或Tab（但不能混用）键缩进就行。 『4』SyntaxError:invalid syntax ：语法错误。最常见的，最基础的错误 英文是“非法语句”的意思。漏标点符号（例如漏分号，漏&amp;号），多标点符号，拼写错，等等都会造成这种错 『5』url连接超时解决：1）使用的是urllib不是urllib2，所以无法直接在urlopen里面加timeout参数，只能是设置全局脚本的超时时间 12import socketsocket.setdefaulttimeout(60) 设置全局的超时时间为60s。 2）urllib，urllib2常会一起使用（两者分别提供不同的功能） 1234html = urllib.urlopen(url).read()# 修改为import urllib2html = urllib2.urlopen(url, timeout=60).read() 『6』UnboundLocalError: local variable ‘appname’ referenced before assignment：123456&#123;u&apos;batchrealnameverifytask&apos;: 99.41, u&apos;bptask100000188408&apos;: 98.77, u&apos;clsexpflowmaintask576&apos;: 101.28&#125;Traceback (most recent call last): File &quot;get_app_cpu_from_influxdb.py&quot;, line 89, in &lt;module&gt; appname = get_sql_info(key) File &quot;get_app_cpu_from_influxdb.py&quot;, line 28, in get_sql_info return appname 变量问题：变量在被赋值之前被使用定义 『7』TypeError: sequence item 1: expected string or Unicode, NoneType found期望值未发现：str或者unicode类型 12345message = u"应用的CPU利用率超过%s,请检查应用:%s"%(str(threshold)+'%',",".join(app_name))# =====================&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;message = "应用的CPU利用率超过%s,请检查应用:%s"%(str(threshold)+'%',",".join(app_name)) 『8』UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xe5 in position 1: ordinal not in range(128)1234# 关于编码问题：import sysreload(sys)sys.setdefaultencoding( "utf-8" ) 『9』IndentationError: unindent does not match any outer indentation level【问题】 一个python脚本，本来都运行好好的，然后写了几行代码，而且也都确保每行都对齐了，但是运行的时候，却出现语法错误： 1IndentationError: unindent does not match any outer indentation level 【解决过程】 1.对于此错误，最常见的原因是，的确没有对齐。但是我根据错误提示的行数，去代码中看了下，没啥问题啊。 都是用TAB键，对齐好了的，没有不对齐的行数啊。 2.以为是前面的注释的内容影响后面的语句的语法了，所以把前面的注释也删除了。 结果还是此语法错误。 3.后来折腾了半天，突然想到了，把当前python脚本的所有字符都显示出来看看有没有啥特殊的字符。tab与空格混用了 『10』request https报错：12# 忽略警告：InsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verification is strongly advised.requests.packages.urllib3.disable_warnings(） 『11』python安装MySQLdb的时候一直有问题在Linux下 1pip install MySQL-python 如果安装之后仍不能正常运行，尝试用yum install MySQL-python，因为这个模块需要一些第三方程序来运行的。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python_problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_问题小结(1)]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2FPython-%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93-1%2F</url>
    <content type="text"><![CDATA[环境：未特别注明的话，均为Python 3.6.5，IDE：VS code 『1』TypeError: unbound method 问题今天执行了下之前写的Python接口文件，源码如下: 12345678910__author__ = 'Administrator'#coding:utf-8from readData import dictionaryreadIt = &#123;&#125;readIt = dictionary.onlyCellValue("E:\python\API\eadData.xls", "Sheet1", 1)print readItfor key in readIt: temp_list = readIt[key] for i in range(0, len(temp_list)): print "第"+(i+1)+"个参数为"+temp_list[i] 在运行时报错：TypeError: unbound method onlyCellValue() must be called with dictionary instance as first argument (got str instance instead)，后经在网上查看，发现时由于调用其他类时，未在后面添加括号，添加括号后，运行正常。这是由于未添加括号情况下，未被认为是类的实例，故报此错； 改正后的：readIt = dictionary().onlyCellValue(“E:\python\API\eadData.xls”, “Sheet1”, 1) 『2』Python访问MySQL听说很多人都使用著名的MySQLdb来访问MySQL(当然还有pymysql)，但是它并不支持Python 3.x的版本。所以要另寻出路。那就是mysql-connector-python，这个貌似是MySQL官方提供的，并且它不依赖于MySQL C客户端library，我下载的是1.1.4版本，下载解压之后，会看到setup.py文件，这样安装： 1sudo python3.2 setup.py install 然后在程序中就可以用了。下面给出一段查询MySQL记录的示例代码： 1234567891011121314151617181920212223242526272829303132import mysql.connectorimport sys __author__ = 'codelast' username = 'root'password = 'xxx'host = '127.0.0.1'db = 'mydb' connection = mysql.connector.connect(user=username, password=password, host=host, database=db)cursor = connection.cursor() sql = "SELECT * FROM my_table WHERE id = 9"try: cursor.execute(sql) # 打印查询到的记录的行数 data = cursor.fetchall() print(len(data)) # 输出所有记录 for (ID, name) in data: print("name:[%s]" % (name)) except mysql.connector.Error as err: print("Failed to query table, detail: &#123;&#125;".format(err.msg)) sys.exit() connection.commit()cursor.close()connection.close() 上面的代码很简单，无非就是从my_table表里查询一些记录，再打印出来。注意 for (ID, name) 中的括号里要写全该表中，你查询的所有字段名，否则会报错。还有其他遍历查询结果的方法，后面会继续陈述。 『3』逆序遍历list123myList = [1, 2, 3]for item in reversed(myList): print(item) 输出： 123321 注意是 reversed 不是 reverse。这只是逆序遍历，myList中的数据顺序并不会改变。 『4』使用MySQLdb访问数据库时，“TypeError: execute() takes at most 3 arguments (4 given)”错误的解决办法Python版本：2.7.3使用2.7.3版本的Python时，访问MySQL的最佳方案应该数使用MySQLdb了。如果在执行SQL时，你遇到了上面所说的问题，那么你可能是像下面这样写导致的： 12sql = "INSERT INTO my_table (field1, field2) VALUES (%s, %s)"cursor.execute(sql, "a", "b") 这是错误的，其实这货根本不是这样用的，当参数多于一个时，你要把它们放在一个tuple里传进去： 12sql = "INSERT INTO my_table (field1, field2) VALUES (%s, %s)"cursor.execute(sql, ("a", "b")) 例如这个链接有个例子。 『5』使用 lxml 库生成XML（字符串）Python版本：2.7.3直接看代码： 12345678910111213141516171819202122232425#coding:UTF-8"""XML生成器。文件名：xmlGenerator.py""" __author__ = 'Darran Zhang @ codelast.com' from lxml import etree class XMLGenerator: def __init__(self): pass def generate_xml(self): commands = etree.Element('Commands') command = etree.SubElement(commands, 'Command') from_user = etree.SubElement(command, 'FromUser') from_user.text = u'abc' cmd = etree.SubElement(command, 'Cmd') cmd.text = u'mmmmmmmmmmmmmm' cmd_extra_data = etree.SubElement(command, 'CmdExtraData') cmd_extra_data.text = u'eeeeeeeeee' return etree.tostring(commands, pretty_print=True, xml_declaration=True, encoding='utf-8') 测试代码： 1234from xmlGenerator import XMLGenerator xmlGen = XMLGenerator()print(xmlGen.generate_xml()) 12345678&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;&lt;Commands&gt; &lt;Command&gt; &lt;FromUser&gt;abc&lt;/FromUser&gt; &lt;Cmd&gt;mmmmmmmmmmmmmm&lt;/Cmd&gt; &lt;CmdExtraData&gt;eeeeeeeeee&lt;/CmdExtraData&gt; &lt;/Command&gt;&lt;/Commands&gt; 可见非常简单。 『6』在PyCharm中无法安装MySQL-python这个package的一个解决办法在PyCharm中可以直接搜索Python package并安装，我遇到的一个问题是：无法安装，错误提示的其中一段为： EnvironmentError: mysql_config not found 你需要保证你的Ubuntu已经安装了以下这些东西： 1sudo apt-get install mysql-server mysql-client libmysqlclient-dev 然后再试，一切OK。 『7』”ValueError: zero length field name in format”错误的解决办法Python版本：2.6.6错误出在如下语句： 1"&#123;&#125;\t&#123;&#125;".format(123, 456) 我遇到的出问题的Python版本为2.6.6（不知道是不是2.6.*及低版本都有此问题），反正Python 2.7.3就没有这个问题了。上面的代码无非主就是把123和456代替两个大括号。在旧版本的Python上（具体从哪个版本开始不用这样写，我不确定），你要有多个需要format的field时，需要指定它们的顺序： 1"&#123;0&#125;\t&#123;1&#125;".format(123, 456) 这样就没问题了。 『8』对一个字典(dict)，按value进行排序Python版本：2.6.6，2.6.9均测试可用（Python3里没有cmp方法了，所以不能用） 123sortedList = sorted(myDict.items(), lambda x, y: cmp(x[1], y[1]), reverse=True)for (k, v) in sortedList: print("&#123;0&#125;\t&#123;1&#125;".format(k,v)) 其中，myDict是你要将其排序的字典，sortedList是排序之后的结果，变成了一个list，里面是若干个tuple，每个tuple里是一对(key,value)，所以后面用那样的方式对它进行了遍历。 『9』判断一个字典（dict）中是否包含指定的key12345678910d = dict()# 向字典中添加两个元素d[1] = 'abc'd[2] = 'def' # 检查 3 这个key是否在字典中，结果输出的是“NO”if 3 in d: print('YES')else: print('NO') 『10』Python正则简单示例先看代码： 12345code = 'String url = "http://item.jd.com/1148104.html?erpad_source=abc";'pattern = re.compile('.*\"(.*)\"')match = pattern.match(code)if match: print(match.group(1)) 输出： 1http://item.jd.com/1148104.html?erpad_source=abc 说明：上面的代码是想把字符串“code”中的双引号里的那个URL打印出来。正则表达式 .\”(.)\” 中的小括号就是第1个group，匹配上的话可以用 group(1) 获取之。 『11』try…except的示例参考123456try: # 可能会出现异常的一段代码 command_1 # 如果command_1出现异常，则不执行command_1以及之后的语句 command_2 # command_1如果正常，则会执行except: # try中任意一行语句出现异常，直接跳转至except，程序继续运行 command_3 command_4 『』To be added…]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python_problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_list去重]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2FPython-list%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[Python_list去重集中记录一下方法怎么快速的对列表进行去重呢，去重之后原来的顺序会不会改变呢？1.以下的几种情况结果是一样的，去重之后顺序会改变:1234567# 最常用ids = [1,2,3,3,4,2,3,4,5,6,1]news_ids = []for id in ids: if id not in news_ids: news_ids.append(id)print news_ids 或用set123# 使用set如果列表里面有字典活着其他数据结构，貌似不会去重。ids = [1,4,3,3,4,2,3,4,5,6,1]ids = list(set(ids)) 或使用itertools.grouby123456import itertoolsids = [1,4,3,3,4,2,3,4,5,6,1]ids.sort()it = itertools.groupby(ids)for k, g in it: print k 关于itertools.groupby的原理可以看这里： (1) http://docs.python.org/2/library/itertools.html#itertools.groupby (2)https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001415616001996f6b32d80b6454caca3d33c965a07611f000 2.怎么能不改变原来的顺序呢？(要用到reduce 关于reduce的介绍 http://docs.python.org/2/library/functions.html#reduce) 关于lambda的文章:http://www.cnblogs.com/nyist-xsk/p/7404675.html 关于reduce的文章: (1) http://www.cnblogs.com/XXCXY/p/5180245.html (2) http://www.pythoner.com/46.html 1234In [5]: ids = [1,4,3,3,4,2,3,4,5,6,1]In [6]: func = lambda x,y:x if y in x else x + [y]In [7]: reduce(func, [[], ] + ids)Out[7]: [1, 4, 3, 2, 5, 6] 其中的 lambda x,y:x if y in x else x + [y] 等价于 lambda x,y: y in x and x or x+[y] 。思路其实就是先把ids变为[[], 1,4,3,……] ,然后在利用reduce的特性. 去列表去重，不改变原来的顺序，还可以使用一个空列表把原列表里面不重复的数据”装起来”，例如：123456789101112131415161718list2 = []list1 = [1,2,3,2,2,2,4,6,5]for i in list1: if i not in list2: list2.append(i)list2[1, 2, 3, 4, 6, 5]或者使用删除元素索引的方法对列表去重，并且不改变原列表的顺序# python for删除的时候会往前移(垃圾回收机制)，未遍历到的后一个占了前一个被删除的"位置"，导致这个数不会被遍历到，而使最后的结果错误# 局部变量在栈内存中存在,当for循环语句结束,那么变量会及时被gc(垃圾回收器)及时的释放掉,不浪费空间；# 如果使用循环之后还想去访问循环语句中控制那个变量,使用while循环。# 所以使用while循环删除nums中的Val(的下标)nums = [1,2,3,3,4,2,3,4,5,6,1]val = 3while val in nums: nums.pop(nums.index(val))print numsreturn len(nums)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python_碎片化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang_问题]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2FGolang-%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[（持续更新） 一、gorm遇到invalid connection报错 (/data/dcops_workspace/src/x.x.x.x/xxxx/model/containerappid_info.go:76)[2019-04-09 14:41:40] invalid connection 现象：今天使用gorm时，总遇到invalid connection报错，导致过一段时间调一下接口服务容器就会重启 网上查了文档看了gorm的mysql连接池的参数： dcosdb.DB().SetMaxIdleConns(10) // SetMaxIdleConns设置idle connection pool的最大连接数。如果MaxOpenConns的值 &gt; 0，但是小于这里设置的MaxIdleConns，则MaxIdleConns将自动降到与MaxOpenConns的限制相同。如果 &lt;= 0, 则没有空闲连接会被保留。最大空闲连接数 dcosdb.DB().SetMaxOpenConns(100) //SetMaxOpenConns用于设置Database最大可以打开的连接数。如果 &lt;= 0, 则没有连接限制。且默认值为0（无限制）。数据库最大连接数 dcosdb.DB().SetConnMaxLifetime(time.Second 5) // SetConnMaxLifetime用于设置连接可被重新使用的最大时间间隔。如果超时，则连接会在重新使用前被关闭。如果 d &lt;= 0, 则连接将被永久保留。**连接最长存活期，超过这个时间连接将不再被复用*** 原因是：程序在重复使用数据库tcp连接池中的某个连接时，该命中连接可能已被服务器过期丢弃，而客户端这边认为该连接为过期，还有效。此时会报错 invalid connection。随后将该连接重连接池中丢弃 原因参考：https://blog.csdn.net/dghpgyss/article/details/86480837 1234// 发现我把dcosdb.DB().SetConnMaxLifetime(time.Second * 5)这个参数设置成了dcosdb.DB().SetConnMaxLifetime(time.Hour)导致了每次连接丢弃，但是客户端不知道。服务端主动关闭了连接，因为服务端对连接的保持超时时间到了也关闭的，所以可以设置客户端连接超时时间小于服务端DB.SetConnMaxLifetime(time.Second)// SetConnMaxLifetime sets the maximum amount of time a connection may be reused.dcosdb.DB().SetConnMaxLifetime(time.Second * 5)// dcosdb.DB().SetConnMaxLifetime(time.Hour) 设置成了1小时 二、]]></content>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker的一些东西]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2FDocker%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF%2F</url>
    <content type="text"><![CDATA[安装问题指北]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一点Haproxy参数的文档]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2F%E8%AE%B0%E4%B8%80%E7%82%B9Haproxy%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[Haproxy的一些配置参数，/etc/haproxy/haproxy.cfg 主要是配置项的超时参数，如下： 1234567891011121314151617181920&gt; # 反映连接haproxy集群报错，查看应用服务器进程大量的端口连接处于colse_wait状态。&gt; # 这个haproxy的redis集群类似配置已经好几组了，配置都相同问啥别的都好好的这个却有问题。&gt; # 自己尝试使用redis-cli连接（haproxy做的redis分片集群），确实能够正常连接操作，但是连接状态马上就会变成close_wait状态，重新执行命令这个close_wait状态会恢复ESTABLISHED，但是细心看端口号已经变化，也就是redis-cli发生了重新连接。于是问题清晰了：用户客户端工具建立链接后，没有自动重连来保持连接，导致超时，服务器主动断开连接，客户端再次链接的时候socket已经损坏不可用了，导致报错&gt; # 解决办法：调整haproxy的超时参数：&gt; timeout connect 5s&gt; timeout queue 5s&gt; timeout client 30s&gt; timeout server 30s&gt; timeout client-fin 30s&gt; timeout server-fin 30s&gt; timeout tunnel 1h&gt; # 参数解释：&gt; timeout connect 连接尝试成功连接到server的超时时间&gt; timeout queue 在队列等待连接槽释放的超时时间&gt; timeout server server端非活动状态超时时间&gt; timeout client 客户端非活动状态超时时间&gt; timeout server-fin 半关闭状态连接，server端非活动超时时间&gt; timeout client-fin 半关闭状态连接，client端非活动超时时间&gt; timeout tunnel 客户端和服务器端通道非活动超时时间&gt;]]></content>
      <tags>
        <tag>Haproxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安静写点东西]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2F%E5%AE%89%E9%9D%99%E5%86%99%E7%82%B9%E4%B8%9C%E8%A5%BF%2F</url>
    <content type="text"><![CDATA[Come on ٩(๑.◡.๑)۶ ，Please ecter Password (*ﾉ▽ﾉ). Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>生活需要一点方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes_填坑]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2FKubernetes-%E5%A1%AB%E5%9D%91%2F</url>
    <content type="text"><![CDATA[更新19.4.5一、etcd 单点问题默认kubeadm创建的集群会在内部启动一个单点的 etcd，当然大部分情况下 etcd 还是很稳定的，但是一但 etcd 由于某种原因挂掉，这个问题会非常严重，会导致整个集群不可用。具体原因是 etcd 存储着 kubernetes 各种元数据信息；包括 kubectl get pod等等基础命令实际上全部是调用 RESTful API 从 etcd 中获取的信息；所以一但 etcd 挂掉以后，基本等同于kubectl命令不可用，集群各节点也会因无法从 etcd 获取数据而出现无法调度，最终挂掉。 解决办法：是在使用kubeadm创建集群时使用 –external-etcd-endpoints 参数指定外部 etcd 集群，此时kubeadm 将不会在内部创建 etcd，转而使用外部我们指定的 etcd 集群，如果外部 etcd 集群配置了 SSL 加密，那么还需要配合 –external-etcd-cafile、–external-etcd-certfile、–external-etcd-keyfile 三个参数指定 etcd 的 CA证书、CA签发的使用证书和私钥文件，命令如下 12345# 非 SSL# kubeadm init --external-etcd-endpoints http://x.x.x.1:2379# etcd SSL# kubeadm init --external-etcd-endpoints https://x.x.x.1:2379 --external-etcd-cafile /path/to/ca --external-etcd-certfile /path/to/cert --external-etcd-keyfile /path/to/privatekey 二、etcd 不可与 master 同在‘愿上帝与你同在’……这个坑是由于kubeadm的 check 机制的 bug 造成的，目前还没有修复；表现为 当 etcd 与 master 在同一节点时，kubeadm init 会失败，同时报错信息提示’已经存在了 /var/lib/etcd 目录，或者 2379 端口被占用’；因为默认kubeadm会创建 etcd，而默认的 etcd 会占用这个目录和 2379 端口，即使你加了--external-etcd-endpoints参数，kubeadm仍然会检测这两项条件是否满足，不满足则禁止 init 操作 解决办法：就是要么外部的 etcd 更换数据目录(/var/lib/etcd)和端口，要么干脆不要和 master 放在同一主机即可 三、巨大的日志熟悉的小伙伴应该清楚，基本上每个 kubernetes 组件都会有个通用的参数 --v；这个参数用于控制 kubernetes 各个组件的日志级别，在早期(alpha)的 kubeadm 版本中，如果不进行调整，默认创建集群所有组件日志级别全部为 --v=4 即最高级别输出，这会导致在业务量大的时候磁盘空间以 ‘我去尼玛’ 的速度增长，尤其是 kube-proxy 组件的容器，会疯狂吃掉你的磁盘空间，然后剩下懵逼的你不知为何。在后续的版本中(beta)发现日志级别已经降到了 --v=2，不过对于完全不怎么看日志的我来说还是无卵用…… 解决办法有两种方案: 1、如果已经 –v=4 跑起来了(检查方法就是随便 describe 一个 kube-proxy 的容器，看下 command 字段就能看到)，并且无法停止重建集群，那么最简单的办法就是使用kubectl edit ds xxx方式编译一下相关 ds 文件等，然后手动杀掉相关 pod，让 kubernetes 自动重建即可，如果命令行用着不爽也可以通过 dashboard 更改 2、如果还没开始搭建，或者可以停掉重建，那么只需在kubeadm init之前export KUBE_COMPONENT_LOGLEVEL=&#39;--v=0&#39;即可 四、新节点加入 dns 要你命当 kubeadm 创建好集群以后，如果有需要增加新节点，那么在 kubeadm join 之后务必检查 kube-dns 组件，dns 在某些(weave 启动不完整或不正常)情况下，会由于新节点加入而挂掉，此时整个集群 dns 失效，所以最好 join 完观察一会 dns 状态，如果发现不正常马上杀掉 dns pod，让 kubernetes 自动重建；如果情况允许最好全部 join 完成后直接干掉 dns 让 kubernetes 重建一下 五、单点的 dns 浪起来让你怕（更新-19.4.5）kubeadm 创建的 dns 默认也是单点的，而 dns 至关重要，只要一挂瞬间整个集群全部 game over；不过暂时还是没有发现能在 init 时候创建多个 dns 的方法；不过在集群创建后可以通过kubectl edit deploy kube-dns的方式修改其副本数量，让其创建多个副本即可，目前新版本kubernetes所使用的dns已经不是单pod三container，而是启动两个pod的coredns，解决单点问题 六、coredns一直处于ContainerCreating状态 Node加入集群中后一直处于NotReady状态，查看kube-system的状态，发现coredns一直处于ContainerCreating状态，flannel启动正常 12345# kubectl get nodesNAME STATUS ROLES AGE VERSIONmaster1.rsq.com NotReady master 16h v1.13.0node01.rsq.com NotReady &lt;none&gt; 16h v1.13.0node02.rsq.com NotReady &lt;none&gt; 8m39s v1.13.0 查看kubelet服务状态，看最后几行的报错 1234567891011121314151617181920212223242526# systemctl status kubelet● kubelet.service - kubelet: The Kubernetes Node Agent Loaded: loaded (/etc/systemd/system/kubelet.service; enabled; vendor preset: disabled) Drop-In: /etc/systemd/system/kubelet.service.d └─10-kubeadm.conf Active: active (running) since Wed 2018-12-12 09:24:44 CST; 6min ago Docs: https://kubernetes.io/docs/ Main PID: 123631 (kubelet) Memory: 35.2M CGroup: /system.slice/kubelet.service └─123631 /usr/bin/kubelet --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf --config=/var/lib/kubelet/config.yaml --cgrou...Dec 12 09:30:57 master1.rsq.com kubelet[123631]: E1212 09:30:57.187292 123631 pod_workers.go:190] Error syncing pod cea84a11-fd24-11e8-a282-000c291e37c2 ("coredns-86c58d9df4-fzs9l_kube-...Dec 12 09:30:57 master1.rsq.com kubelet[123631]: E1212 09:30:57.187480 123631 pod_workers.go:190] Error syncing pod cea7ebef-fd24-11e8-a282-000c291e37c2 ("coredns-86c58d9df4-hrwvk_kube-...Dec 12 09:30:59 master1.rsq.com kubelet[123631]: E1212 09:30:59.187419 123631 pod_workers.go:190] Error syncing pod cea84a11-fd24-11e8-a282-000c291e37c2 ("coredns-86c58d9df4-fzs9l_kube-...Dec 12 09:30:59 master1.rsq.com kubelet[123631]: E1212 09:30:59.187607 123631 pod_workers.go:190] Error syncing pod cea7ebef-fd24-11e8-a282-000c291e37c2 ("coredns-86c58d9df4-hrwvk_kube-...Dec 12 09:31:00 master1.rsq.com kubelet[123631]: W1212 09:31:00.454147 123631 cni.go:203] Unable to update cni config: No networks found in /etc/cni/net.dDec 12 09:31:00 master1.rsq.com kubelet[123631]: E1212 09:31:00.454242 123631 kubelet.go:2192] Container runtime network not ready: NetworkReady=false reason:NetworkPluginNot...initializedDec 12 09:31:01 master1.rsq.com kubelet[123631]: E1212 09:31:01.188877 123631 pod_workers.go:190] Error syncing pod cea7ebef-fd24-11e8-a282-000c291e37c2 ("coredns-86c58d9df4-hrwvk_kube-...Dec 12 09:31:01 master1.rsq.com kubelet[123631]: E1212 09:31:01.189259 123631 pod_workers.go:190] Error syncing pod cea84a11-fd24-11e8-a282-000c291e37c2 ("coredns-86c58d9df4-fzs9l_kube-...Dec 12 09:31:03 master1.rsq.com kubelet[123631]: E1212 09:31:03.187200 123631 pod_workers.go:190] Error syncing pod cea84a11-fd24-11e8-a282-000c291e37c2 ("coredns-86c58d9df4-fzs9l_kube-...Dec 12 09:31:03 master1.rsq.com kubelet[123631]: E1212 09:31:03.187730 123631 pod_workers.go:190] Error syncing pod cea7ebef-fd24-11e8-a282-000c291e37c2 ("coredns-86c58d9df4-hrwvk_kube-...Hint: Some lines were ellipsized, use -l to show in full.# 附加PS# 报错10.244.0.1 网络已存在（更新） 产生问题原因： 一直报网络NotReady，我就感觉flannel组件出了问题， 最后网上搜了一些资料解决参考博客：coreDNS一直处于创建中解决解决办法：所有节点执行（我只在master节点先执行就解决问题了） 12# rm -rf /var/lib/cni/flannel/* &amp;&amp; rm -rf /var/lib/cni/networks/cbr0/* &amp;&amp; ip link delete cni0# rm -rf /var/lib/cni/networks/cni0/* 删除flannel组件，重新下载 12# docker rmi quay.io/coreos/flannel:v0.10.0-amd64# kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml 查看节点状态已经处于Ready状态 12345# kubectl get nodesNAME STATUS ROLES AGE VERSIONmaster1.rsq.com Ready master 16h v1.13.0node01.rsq.com Ready &lt;none&gt; 16h v1.13.0node02.rsq.com Ready &lt;none&gt; 39m v1.13.0 七、kubeadm join报错12345678910在部署服务过程中，初始化之后重启了master节点，然后node节点在join进群的时候报错，提示证书是否过期等问题，报错信息如下：# kubeadm join 10.0.0.100:6443 --token qxl5b3.5b78nwu3gm1r4u6o --discovery-token-ca-cert-hash sha256:3e20fa8054cbc9000cf3d3586a05a01d8af5721b577856e93c7e243877393d21 --ignore-preflight-errors=Swap[preflight] Running pre-flight checks[WARNING Swap]: running with swap on is not supported. Please disable swap [WARNING SystemVerification]: this Docker version is not on the list of validated versions: 18.09.0. Latest validated version: 18.06[discovery] Trying to connect to API Server "10.0.0.100:6443"[discovery] Created cluster-info discovery client, requesting info from "https://10.0.0.100:6443"[discovery] Failed to request cluster info, will try again: [Get https://10.0.0.100:6443/api/v1/namespaces/kube-public/configmaps/cluster-info: dial tcp 10.0.0.100:6443: connect: connection refused][discovery] Failed to request cluster info, will try again: [Get https://10.0.0.100:6443/api/v1/namespaces/kube-public/configmaps/cluster-info: dial tcp 10.0.0.100:6443: connect: connection refused] 产生原因：有可能是时间不同步造成的，在初始化后重启master，重启后会报错 找了好多资料，没有找到可行的，最后kubeadm reset完美解决参考博文： k8s踩坑记 - kubeadm join 之 token 失效reset之后重新初始化 12# kubeadm reset # kubeadm init --kubernetes-version=v1.13.0 --pod-network-cidr=10.244.0.0/16 --service-cidr=10.96.0.0/12 --token-ttl=0 --ignore-preflight-errors=Swap 创建所需文件 123# mkdir -p $HOME/.kube# cp -i /etc/kubernetes/admin.conf $HOME/.kube/config# chown $(id -u):$(id -g) $HOME/.kube/config 查看节点 123# kubectl get nodesNAME STATUS ROLES AGE VERSIONmaster1.rsq.com NotReady master 2m49s v1.13.0 八、Etcd二进制安装目录也会报错哦etcd服务启动后报错etcd cluster ID mismatch：检查service配置cluster选项有无问题，若无问题，则可能是此前的etcd bootstrap加速启动缓存残留导致，坑爹的是rm -rf /var/lib/etcd/*删除完了之后还是报错，必须rm -rf /var/lib/etcd/才能彻底清除，删除完成后记得再创建该路径mkdir /var/lib/etcd，否则会有类似报错： 1etcd.service: Failed at step CHDIR spawning /usr/local/bin/etcd: No such file or directory 九、二进制安装后重建相关组件会出现secrets报错123May 27 10:34:45 kube-node3 journal: E0527 02:34:45.767392 1 config.go:322] Expected to load root CA config from /var/run/secrets/kubernetes.io/serviceaccount/ca.crt, but got err: open /var/run/secrets/kubernetes.io/serviceaccount/ca.crt: no such file or directory May 27 10:34:45 kube-node3 journal: E0527 02:34:45.767392 1 config.go:322] Expected to load root CA config from /var/run/secrets/kubernetes.io/serviceaccount/ca.crt, but got err: open /var/run/secrets/kubernetes.io/serviceaccount/ca.crt: no such file or directory 分析：产生这个错误是因为Kubernetes默认创建的secrets资源不包含用于访问kube-apiserver的根证书 需要给apiserver设置安全证书，然后删除默认secrets，系统会自动产生新的secrets secrets一般集群安装时默认自动创建 1# kubectl delete secret secretname -n Xxx 十、kubeadm生成集群，加入节点时发现忘记了join token 怎么办？ 1.生成一条永久有效的token 12345678&gt; # kubeadm token create --ttl 0 &gt; o4avtg.65ji6b778nyacw68 &gt; &gt; # kubeadm token list &gt; TOKEN TTL EXPIRES USAGES DESCRIPTION EXTRA GROUPS &gt; dxnj79.rnj561a137ri76ym &lt;invalid&gt; 2018-11-\#02T14:06:43+08:00 authentication,signing &lt;none&gt; system:bootstrappers:kubeadm:default-node-token &gt; o4avtg.65ji6b778nyacw68 &lt;forever&gt; &lt;never&gt; authentication,signing &lt;none&gt; system:bootstrappers:kubeadm:default-node-token &gt; 2.获取ca证书sha256编码hash值 1234&gt; # openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed 's/^.* //' &gt; &gt; 2cc3029123db737f234186636330e87b5510c173c669f513a9c0e0da395515b0 &gt; 3.node节点加入 12&gt; # kubeadm join x.x.x.x:6443 --token o4avtg.65ji6b778nyacw68 --discovery-token-ca-cert-hash sha256:2cc3029123db737f234186636330e87b5510c173c669f513a9c0e0da395515b0 &gt;]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>kubernetes_problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes安装—kubeadm_1.13.5]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2FKubernetes%E5%AE%89%E8%A3%85%E2%80%94kubeadm-1-13-5%2F</url>
    <content type="text"><![CDATA[环境描述 kubernetes version：1.13.5 docker version：18.6.3 Redhat：7.6 linux 内核：4.2.0 x.x.x.1 master-1 kube-apiserver、kube-controller-manager、kube-scheduler、etcd、keepalive、docker x.x.x.2 master-2 kube-apiserver、kube-controller-manager、kube-scheduler、etcd、keepalive、docker x.x.x.3 master-3 kube-apiserver、kube-controller-manager、kube-scheduler、etcd、keepalive、docker x.x.x.4 vip x.x.x.5 node-1 kubelet、docker x.x.x.6 node-2 kubelet、docker 因为担心kubeadm起来的etcd不稳定，这里用到的etcd对于kubernetes来说作为外部etcd集群。即使用二进制安装etcd集群，其余组件用kubeadm来完成安装。 环境准备1、准备工作12345678910111213141516echo "1" &gt; /proc/sys/net/bridge/bridge-nf-call-iptables# 停防火墙systemctl stop firewalldsystemctl disable firewalldsystemctl disable firewalld# 关闭Swapswapoff -ased 's/.*swap.*/#&amp;/' /etc/fstab# 关闭防火墙systemctl disable firewalld &amp;&amp; systemctl stop firewalld &amp;&amp; systemctl status firewalld# 关闭Selinuxsetenforce 0sed -i "s/^SELINUX=enforcing/SELINUX=disabled/g" /etc/sysconfig/selinuxsed -i "s/^SELINUX=enforcing/SELINUX=disabled/g" /etc/selinux/configsed -i "s/^SELINUX=permissive/SELINUX=disabled/g" /etc/sysconfig/selinuxsed -i "s/^SELINUX=permissive/SELINUX=disabled/g" /etc/selinux/config 2、docker安装1、下载设置源123sudo yum install -y yum-utils \ device-mapper-persistent-data \ lvm2 123yum-config-manager \--add-repo \https://download.daocloud.io/docker/linux/centos/docker-ce.repo 2、安装docker123yum list docker-ce --showduplicates | sort -r # 列出docker-ce的版本listyum install docker-ce-&lt;版本号&gt; -y # -y 安装docker需要的依赖，其中有个container-selinux的也可以单独下载# rpm -ivh container-selinux-2.33-1.git86f33cd.el7.noarch.rpm 3、启动docker12systemctl start dockerdocker version # 验证docker安装是否完成并启动成功 3、kubeadm/kubelet/kubectl安装 各节点安装 1234567891011121314cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOFyum install -y kubelet-1.13.5 kubeadm-1.13.5 kubectl-1.13.5 --disableexcludes=kubernetes #禁用除kubernetes之外的仓库,要用 -y 参数，会自动安装kube-cni等插件systemctl start kubeletsystemctl enable kubelet # kubeadm 要求kubelet保持开机自启状态 4、keepalive安装 master节点安装： 123456789101112131415161718192021222324252627282930313233343536373839404142yum install -y keepalivedsystemctl start keepalivedvim /etc/keepalived/keepalived.confglobal_defs &#123; router_id LVS_k8s&#125;vrrp_script CheckK8sMaster &#123; script &quot;curl -k https://10.70.49.130:6443&quot; interval 3 timeout 9 fall 2 rise 2&#125;vrrp_instance VI_1 &#123; state MASTER interface ens256 # 网卡 virtual_router_id 61 # 主节点权重最高 依次减少 priority 120 advert_int 1 #修改为本地IP mcast_src_ip x.x.x.2 nopreempt authentication &#123; auth_type PASS auth_pass sqP05dQgMSlzrxHj &#125; unicast_peer &#123; x.x.x.1 #x.x.x.2 x.x.x.3 &#125; virtual_ipaddress &#123; x.x.x.4 &#125; track_script &#123; CheckK8sMaster &#125;&#125; kubernetes部署1、etcd二进制部署1234567891011# 1.cfssl签发证书wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64chmod +x cfssl_linux-amd64mv cfssl_linux-amd64 /usr/local/bin/cfsslwget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64chmod +x cfssljson_linux-amd64mv cfssljson_linux-amd64 /usr/local/bin/cfssljsonwget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64chmod +x cfssl-certinfo_linux-amd64mv cfssl-certinfo_linux-amd64 /usr/local/bin/cfssl-certinfoexport PATH=/usr/local/bin:$PATH 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 2.根据config.json文件的格式创建如下的ca-config.json文件,过期时间设置成了 87600hmkdir /root/sslcd /root/sslcfssl print-defaults config &gt; config.jsoncfssl print-defaults csr &gt; csr.jsoncat &gt; ca-config.json &lt;&lt;EOF&#123; "signing": &#123; "default": &#123; "expiry": "87600h" &#125;, "profiles": &#123; "kubernetes": &#123; "usages": [ "signing", "key encipherment", "server auth", "client auth" ], "expiry": "87600h" &#125; &#125; &#125;&#125;EOFcat &gt; ca-csr.json &lt;&lt;EOF&#123; "CN": "kubernetes", "key": &#123; "algo": "rsa", "size": 2048 &#125;, "names": [ &#123; "C": "CN", "ST": "BeiJing", "L": "BeiJing", "O": "k8s", "OU": "System" &#125; ]&#125;EOFcfssl gencert -initca ca-csr.json | cfssljson -bare ca 12345678910111213141516171819202122232425262728293031323334# 3.创建kubernetes-etcd证书cat &gt; kubernetes-etcd-csr.json &lt;&lt;EOF&#123; "CN": "kubernetes", "hosts": [ "x.x.x.1", "x.x.x.2", "x.x.x.3", "x.x.x.4", "127.0.0.1", "10.254.0.1", "kubernetes", "kubernetes.default", "kubernetes.default.svc", "kubernetes.default.svc.cluster", "kubernetes.default.svc.cluster.local" ], "key": &#123; "algo": "rsa", "size": 2048 &#125;, "names": [ &#123; "C": "CN", "ST": "BeiJing", "L": "BeiJing", "O": "k8s", "OU": "System" &#125; ]&#125;EOFcfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kubernetes-etcd-csr.json | cfssljson -bare etcd 123456# 4.目录证书文件如下etcd-key.pem etcd.pem ca.pem ca.key# 保证三节点证书一致scp /etc/etcd/ssl/* master2:/etc/etcd/ssl/scp /etc/etcd/ssl/* master3:/etc/etcd/ssl/ 证书生成完毕之后，将CA证书ca.pem, etcd秘钥etcd-key.pem, etcd证书etcd.pem拷贝到各节点的/etc/etcd/ssl目录中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# 这里就用etcd 3.3.10版本# 一：wget https://github.com/coreos/etcd/releases/download/v3.3.10/etcd-v3.3.10-linux-amd64.tar.gz# 解压缩etcd-v3.3.10-linux-amd64.tar.gz，将其中的etcd和etcdctl两个可执行文件复制到各节点的/usr/bin和/usr/local/bin目录。tar zxvf etcd-v3.3.10-linux-amd64.tar.gzcp etcd-v3.3.10-linux-amd64/etcd* /usr/local/bin/cp etcd-v3.3.10-linux-amd64/etcd* /usr/bin/mkdir /var/lib/etcd #etcd的数据目录mkdir /etc/etcd #etcd的配置文件目录# 二：yum -y install etcd# 安装好etcd之后，就可以修改etcd配置以及启动service，文件路径为：/etc/etcd/etcd.conf和/usr/lib/systemd/system/etcd.servicecat &gt; /etc/etcd/etcd.conf &lt;&lt; EOF# [member]ETCD_NAME=etcd1 # etcd名字 三节点的话为 etcd1 etcd2 etcd3ETCD_DATA_DIR="/data/etcd" # etcd数据目录指定ETCD_LISTEN_PEER_URLS="https://x.x.x.1:2380" # 修改每个master节点的ipETCD_LISTEN_CLIENT_URLS="https://x.x.x.1:2379"#[cluster]ETCD_INITIAL_ADVERTISE_PEER_URLS="https://x.x.x.1:2380"ETCD_INITIAL_CLUSTER_TOKEN="etcd-cluster"ETCD_ADVERTISE_CLIENT_URLS="https://x.x.x.1:2379"EOFcat &gt; /usr/lib/systemd/system/etcd.service &lt;&lt; EOF[Unit]Description=Etcd ServerAfter=network.targetAfter=network-online.targetWants=network-online.targetDocumentation=https://github.com/coreos[Service]Type=notifyWorkingDirectory=/var/lib/etcd/EnvironmentFile=-/etc/etcd/etcd.confExecStart=/usr/local/bin/etcd \ --name $&#123;ETCD_NAME&#125; \ --cert-file=/etc/etcd/ssl/etcd.pem \ --key-file=/etc/etcd/ssl/etcd-key.pem \ --peer-cert-file=/etc/etcd/ssl/etcd.pem \ --peer-key-file=/etc/etcd/ssl/etcd-key.pem \ --trusted-ca-file=/etc/etcd/ssl/ca.pem \ --peer-trusted-ca-file=/etc/etcd/ssl/ca.pem \ --initial-advertise-peer-urls $&#123;ETCD_INITIAL_ADVERTISE_PEER_URLS&#125; \ --listen-peer-urls $&#123;ETCD_LISTEN_PEER_URLS&#125; \ --listen-client-urls $&#123;ETCD_LISTEN_CLIENT_URLS&#125;,http://127.0.0.1:2379 \ --advertise-client-urls $&#123;ETCD_ADVERTISE_CLIENT_URLS&#125; \ --initial-cluster-token $&#123;ETCD_INITIAL_CLUSTER_TOKEN&#125; \ --initial-cluster etcd1=https://x.x.x.1:2380,etcd2=https://x.x.x.2:2380,etcd3=https://x.x.x.3:2380 \ --initial-cluster-state new \ --data-dir=$&#123;ETCD_DATA_DIR&#125;Restart=on-failureRestartSec=5LimitNOFILE=65536[Install]WantedBy=multi-user.targetEOF# 上面在启动参数中指定了etcd的工作目录和数据目录分别是/var/lib/etcd和/data/etcd# –cert-file和–key-file分别指定etcd的公钥证书和私钥# –peer-cert-file和–peer-key-file分别指定了etcd的Peers通信的公钥证书和私钥。# –trusted-ca-file指定了客户端的CA证书# –peer-trusted-ca-file指定了Peers的CA证书# –initial-cluster-state new表示这是新初始化集群，–name指定的参数值必须在–initial-cluster中# 高可用etcd启动需要多节点同时启动才能起来服务# 分别在master节点同时启动etcdsystemctl start etcd.servicesystemctl enable etcd.service 至此，etcd高可用集群搭建完成，可用一下命令验证etcd集群 123456etcdctl \ --ca-file=/etc/etcd/ssl/ca.pem \ --cert-file=/etc/etcd/ssl/etcd.pem \ --key-file=/etc/etcd/ssl/etcd-key.pem \ --endpoints=https://x.x.x.1:2379,https://x.x.x.2:2379,https://x.x.x.3:2379 \ cluster-health 2、kubeadm部署1、master部署 部署之前请确保下载好相关image，翻墙下载或者国内dockerhub下载kubernetes镜像 1、初始化master1 创建master1的初始化配置文件,网络插件采用flannel，CIDR地址是 “10.244.0.0/16”，如下为1.13.5新版本配置文件。 123456789101112131415161718192021222324252627282930313233cat &gt; kubeadm-master.yaml &lt;&lt; EOFapiVersion: kubeadm.k8s.io/v1beta1kind: InitConfigurationlocalAPIEndpoint: advertiseAddress: x.x.x.1 # 本机ip，这里为x.x.x.1-3 bindPort: 6443---apiVersion: kubeadm.k8s.io/v1beta1kind: ClusterConfigurationkubernetesVersion: v1.13.5 # kubernetes版本 对应下载的imageimageRepository: k8s.gcr.io # 自己修改为自己的镜像库名apiServer: certSANs: - "master1" - "master2" - "master3" - "x.x.x.1" - "x.x.x.2" - "x.x.x.3" - "x.x.x.4" - "127.0.0.1"controlPlaneEndpoint: "x.x.x.4:8443" # 控制台ip指定，即vip 实现apiserver高可用etcd: external: endpoints: - https://x.x.x.1:2379 - https://x.x.x.2:2379 - https://x.x.x.3:2379networking: podSubnet: "10.244.0.0/16"EOF 123# 运行初始化命令即可，前提要把相关设置关闭，详情至准备工作# 其中在kubelet配置里加入--pod-infra-container-image 参数指定 pause私有镜像库镜像kubeadm init --config kubeadm-master.yaml 在初始化配置里，对于etcd有两种高可用的选项，一个使用内部etcd，一个使用外部etcd(独立搭建的etcd集群，而不是在初始化中搭建的)，两者初始化配置文件略有不同。 1234567891011121314151617# 使用内部etcd的话，初始化yaml文件中etcd配置如下：etcd: local: extraArgs: listen-client-urls: "https://127.0.0.1:2379,https://x.x.x.x:2379" advertise-client-urls: "https://x.x.x.x:2379" listen-peer-urls: "https://x.x.x.x:2380" initial-advertise-peer-urls: "https://x.x.x.x:2380" initial-cluster: "master1.hanli.com=https://x.x.x.x:2380"# 使用外部etcd的话，etcd: #ETCD的地址 external: endpoints: - https://x.x.x.1:2379 - https://x.x.x.2:2379 - https://x.x.x.3:2379 init初始化之后，如果成功会出现join，这时就可以运行一下命令 机器上的用户要使用kubectl来管理集群操作集群 123mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config 验证命令 1234567891011kubectl get cs # 如下信息NAME STATUS MESSAGE ERRORcontroller-manager Healthy okscheduler Healthy oketcd-1 Healthy &#123;"health": "true"&#125;etcd-0 Healthy &#123;"health": "true"&#125;etcd-2 Healthy &#123;"health": "true"&#125;kubectl get node # notReady 状态，是因为没有安装网络插件 Name成ip，可修改kubelet的启动参数即可NAME STATUS ROLES AGE VERSIONmaster1 NotReady master 1m v1.13.5 2、启动flannel服务123456789101112wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml# flannel 默认会使用主机的第一张网卡，如果你有多张网卡，需要通过配置单独指定。修改 kube-flannel.yml 中的以下部分cat kube-flannel.yml containers: - name: kube-flannel image: quay.io/coreos/flannel:v0.11.0-amd64 # 修改下自己私有镜像库的flannel镜像名 command: - /opt/bin/flanneld args: - --ip-masq - --kube-subnet-mgr - --iface=ens33 #添加 1234567891011121314kubectl apply -f kube-flannel.yml # 创建pod，因为是ds的所以后续集群里面加节点就会自动启动flannelkubectl get node # 会发现 node状态变成了 ReadyNAME STATUS ROLES AGE VERSIONmaster1 Ready master 10m v1.13.5kubectl get po --all-namespacesNAMESPACE NAME READY STATUS RESTARTS AGEkube-system coredns-86c58d9df4-r59rv 1/1 Running 0 59mkube-system coredns-86c58d9df4-rbzx5 1/1 Running 0 59mkube-system kube-apiserver-master1 1/1 Running 0 58mkube-system kube-controller-manager-master1 1/1 Running 16 58mkube-system kube-flannel-ds-amd64-229j2 1/1 Running 0 42mkube-system kube-proxy-4wrg5 1/1 Running 0 59mkube-system kube-scheduler-master1 1/1 Running 13 58m 不是running状态，就说明出错了，通过查看 描述：kubectl describe pod kube-scheduler-master.hanli.com -n kube-system 日志：kubectl logs kube-scheduler-master.hanli.com -n kube-system flannel服务启动成功后，coredns也就会自动启动成功，状态为Running 3、初始化其他master节点 首先把master1上生成的ca证书等，拷贝到其他master节点上，最好免密，可使用pscp等批量任务 12345678910111213&gt; #!/bin/bash&gt; #注意修改为自己的主机名&gt; export CONTROL_PLANE_IPS="master2 master3" &gt; &gt; # 保证节点有/etc/kubernetes/pki目录&gt; # 把以下证书复制到其他master节点&gt; for host in $&#123;CONTROL_PLANE_IPS&#125;; do&gt; scp /etc/kubernetes/pki/*.crt $host:/etc/kubernetes/pki/&gt; scp /etc/kubernetes/pki/*.key $host:/etc/kubernetes/pki/&gt; scp /etc/kubernetes/pki/*.pub $host:/etc/kubernetes/pki/&gt; scp /etc/kubernetes/admin.conf $host:/etc/kubernetes/admin.conf&gt; done&gt; 1234567891011121314151617&gt; tree /etc/kubernetes/pki/&gt; /etc/kubernetes/pki/&gt; ├── apiserver.crt&gt; ├── apiserver-etcd-client.crt&gt; ├── apiserver-etcd-client.key&gt; ├── apiserver.key&gt; ├── apiserver-kubelet-client.crt&gt; ├── apiserver-kubelet-client.key&gt; ├── ca.crt&gt; ├── ca.key&gt; ├── front-proxy-ca.crt&gt; ├── front-proxy-ca.key&gt; ├── front-proxy-client.crt&gt; ├── front-proxy-client.key&gt; ├── sa.key&gt; └── sa.pub&gt; In v1.8.0, kubeadm introduced the kubeadm alpha phase command with the aim of making kubeadm more modular. In v1.13.0 this command graduated to kubeadm init phase. This modularity enables you to invoke atomic sub-steps of the bootstrap process. Hence, you can let kubeadm do some parts and fill in yourself where you need customizations. kubeadm init phase is consistent with the kubeadm init workflow, and behind the scene both use the same code. 在v1.8.0中，kubeadm引入了该kubeadm alpha phase命令，目的是使kubeadm更加模块化。在v1.13.0中，此命令逐渐变为kubeadm init phase。此模块化使您可以调用引导过程的原子子步骤。因此，您可以让kubeadm执行某些操作，并在需要自定义的位置填写您自己的位置。 kubeadm init phase与kubeadm init工作流程一致，并且在场景后面都使用相同的代码。 123kubectl init --config kube-master.yaml# 分别修改对应ip，在在master2-3并执行即可 步骤如master1# 等待kube-proxy flannel启动成功即可 1234567891011121314151617181920kubectl get po -n kube-systemNAME READY STATUS RESTARTS AGEcoredns-9f9d9c76-4zrt4 1/1 Running 0 2dcoredns-9f9d9c76-dqd4c 1/1 Running 0 2dkube-apiserver-zjjh-rq-k8s-1 1/1 Running 0 2dkube-apiserver-zjjh-rq-k8s-2 1/1 Running 0 2dkube-apiserver-zjjh-rq-k8s-3 1/1 Running 0 2dkube-controller-manager-zjjh-rq-k8s-1 1/1 Running 0 2dkube-controller-manager-zjjh-rq-k8s-2 1/1 Running 0 2dkube-controller-manager-zjjh-rq-k8s-3 1/1 Running 0 2dkube-flannel-ds-amd64-7ghn7 1/1 Running 1 2dkube-flannel-ds-amd64-9cqts 1/1 Running 0 2dkube-flannel-ds-amd64-f57nh 1/1 Running 1 2dkube-proxy-8fwts 1/1 Running 0 2dkube-proxy-95tjb 1/1 Running 0 2dkube-proxy-bls94 1/1 Running 0 2dkube-scheduler-zjjh-rq-k8s-1 1/1 Running 0 2dkube-scheduler-zjjh-rq-k8s-2 1/1 Running 0 2dkube-scheduler-zjjh-rq-k8s-3 1/1 Running 0 2dkubernetes-dashboard-67d49f7868-x79wf 1/1 Running 0 76m 2、Work节点加入集群 输入master节点初始化成功之后出现的join命令，出现kubectl get nodes即成功 12&gt; kubeadm join x.x.x.4:8443 --token bnnsb7.amapp1t78llxn54d --discovery-token-ca-cert-hash sha256:520ef89be84c30e480db6d441a7e4179634a9455f0009e249ebe8f35fa792087&gt; 3、集群验证1234567891011121314151617181920# 节点状态[root@master] ~$ kubectl get nodes# 组件状态[root@master] ~$ kubectl get cs# 服务账户[root@master] ~$ kubectl get serviceaccount# 集群信息[root@master] ~$ kubectl cluster-info# 验证dns功能[root@master] ~$ kubectl run curl --image=radial/busyboxplus:curl -it[ root@curl-66959f6557-r4crd:/ ]$ nslookup kubernetes.defaultServer: 10.96.0.10Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.localName: kubernetes.defaultAddress 1: 10.96.0.1 kubernetes.default.svc.cluster.local 附录： 12&gt;# kubelet.service配置文件 /use/lib/systemd/system/kubelet.service.d/10-kubeadm.conf&gt; 参考链接： kubeadm安装1.13.5：https://blog.csdn.net/fanren224/article/details/86573264#2master1_165 二进制安装：https://github.com/mritd/ktool 二进制安装kubernetes_v1.13.4：https://mritd.me/2019/03/16/set-up-kubernetes-1.13.4-cluster/]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang并发之sync.WaitGroup]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2FGolang%E5%B9%B6%E5%8F%91%E4%B9%8Bsync-WaitGroup%2F</url>
    <content type="text"><![CDATA[声明1var wg sync.WaitGroup sync.WaitGroup/ Golang内置sync包 Wg变量：该类型有三个指针方法，即Add、Done和Wait。 类型sync.WaitGroup是一个结构体类型。当一个sync.WaitGroup类型的变量被声明之后，其值中的那个计数值将会是0。 我们可以通过该值的Add方法增大或减少其中的计数值。 如下： wg.Add(1) 与wg.Add(-1)的执行效果是一致的： wg.Done() 总结: 1、使用Done方法禁忌与Add方法的一样——不要让相应的计数值变为负数。 例如，这段代码中的第5条语句会引发一个运行时恐慌： var wg sync.WaitGroup wg.Add(2) wg.Done() wg.Done() wg.Done() 2、当我们调用sync.WaitGroup类型值的Wait方法的时候，它会去检查该值中的计数值。如果这个计数值为0，那么该方法会立即返回，且不会对程序的运行产生任何影响。 但是，如果这个计数值大于0，那么该方法的调用方所属的那个Goroutine就会被阻塞。直到该计数值重新变为0之时，为此而被阻塞的所有Goroutine才会被唤醒。 代码案例1234567891011121314151617181920212223242526272829303132333435// 协调多个Goroutine的运行。假设，在我们的程序中启用了4个Goroutine，分别是G1、G2、G3和G4。其中，G2、G3和G4是由G1中的代码启用并被用于执行某些特定任务的。G1在启用这3个Goroutine之后要等待这些特定任务的完成。// 方案1（channel通道）sign := make(chan byte, 3)go func() &#123; //G2 sign &lt;- 2&#125;()go func() &#123; //G3 sign &lt;- 3&#125;()go func() &#123; //G4 sign &lt;- 4&#125;()for i := 0; i &lt; 3; i++ &#123;fmt.Printf("G%d is ended.\n", &lt;-sign)&#125;// 方案2（sync.WaitGroup）var wg sync.WaitGroupwg.Add(3)go func() &#123; //G2 wg.Done()&#125;()go func() &#123; //G3 wg.Done()&#125;()go func() &#123; //G4 wg.Done()&#125;()wg.Wait()fmt.Println("Finish") 12345678910111213141516171819202122package mainimport ( "fmt" "sync" "time")func main() &#123; var wg sync.WaitGroup for i := 0; i &lt; 5; i = i + 1 &#123; wg.Add(1) go func(n int) &#123; // defer wg.Done() defer wg.Add(-1) EchoNumber(n) &#125;(i) // n = i &#125; wg.Wait()&#125;func EchoNumber(i int) &#123; time.Sleep(3e9) fmt.Println(i)&#125;]]></content>
      <categories>
        <category>Golang并发</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang并发之原子操作]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2FGolang%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1、]]></content>
      <categories>
        <category>Golang并发</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo入坑-主题篇]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2FHexo%E5%85%A5%E5%9D%91-%E4%B8%BB%E9%A2%98%E7%AF%87%2F</url>
    <content type="text"></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo入坑-安装篇]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2FHexo%E5%85%A5%E5%9D%91-%E5%AE%89%E8%A3%85%E7%AF%87%2F</url>
    <content type="text"><![CDATA[准备 有一个github账号，没有的话去注册一个 安装了git、node.js、npm，并了解相关基础知识 12node -vgit --version 安装了git for Mac（或者其它git客户端） 安装1. 创建github仓库​ github上新建一个名为用户名.github.io的项目，例如：sheldon-lu.github.io， 这个项目名是用来做域名用的，当然也可以去申请一个属于自己的域名，一般推荐godaddy 2. 配置SSH key免密上传不详细讲了，命令如下： 1234567891011cd ~/.ssh# 检查本机已存在的ssh密钥# 如果提示：No such file or directory 说明你是第一次使用git。ssh-keygen -t rsa -C "邮件地址"# 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key# 测试是否成功，验证命令：ssh -T git@GitHub.com## Hi cnfeat! You've successfully authenticated, but GitHub does not provide shell access.出现这个就是成功了，之后可以测试一下push是否免密上传。# 此时你可能还需要配置，这个属于全局config，对于git项目完全可以git clone下来之后进行push等等操作：git config --global user.name "liuxianan"// 你的github用户名，非昵称git config --global user.email "xxx@qq.com"// 填写你的github注册邮箱 3. Hexo安装及介绍官网： http://hexo.io github: https://github.com/hexojs/hexo 由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 安装之前先来说几个注意事项： 很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行（对于windows用户而言）； hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导； hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的； 这里给官网上的部署命令： 1234567891011mkdir &lt;Your blog&gt; # 创建blog文档文件夹npm install hexo-cli -g # 安装hexo以及hexo命令# 初始化一个blog项目，其中'blog'为你的blog名字，hexo会自动下载一些文件到这个目录，包括node_modules.hexo init blogcd blognpm installhexo server## 这两个命令是经常会用到的hexo s -g #生成并本地预览hexo d -g #生成并上传 对于mac用户，如果遇到以下报错： 123456789101112131415161718安装npm install hexo-cli -g时报错npm install hexo -gnpm WARN locking Error: EACCES, open &apos;/Users/lushenneng/.npm/_locks/hexo-4ded2cf5ea4a8daa.lock&apos;npm WARN locking at Error (native)npm WARN locking /Users/lushenneng/.npm/_locks/hexo-4ded2cf5ea4a8daa.lock failed &#123; [Error: EACCES, open &apos;/Users/lushenneng/.npm/_locks/hexo-4ded2cf5ea4a8daa.lock&apos;]npm WARN locking errno: -13,npm WARN locking code: &apos;EACCES&apos;,npm WARN locking path: &apos;/Users/lushenneng/.npm/_locks/hexo-4ded2cf5ea4a8daa.lock&apos; &#125;npm ERR! Darwin 14.0.0npm ERR! argv &quot;node&quot; &quot;/usr/bin/npm&quot; &quot;install&quot; &quot;hexo&quot; &quot;-g&quot;npm ERR! node v0.12.3npm ERR! npm v2.9.1npm ERR! Attempt to unlock /usr/lib/node_modules/hexo, which hasn&apos;t been lockednpm ERR!npm ERR! If you need help, you may report this error at:npm ERR! https://github.com/npm/npm/issuesnpm ERR! Please include the following file with any support request:npm ERR! /Users/lushenneng/blog/npm-debug.log 解决： 12345# 可以先用这个命令：sudo npm install hexo-cli -g# 如果还是报错可以用这个命令：sudo npm install --unsafe-perm --verbose -g hexo# 加上sudo一般能解决很多问题 4. START Hexo在blog目录下的_config.yml配置修改如下：(大概是在最后一行) 12345deploy: type: git repository: github: git@github.com:sheldon-lu/sheldon_blog.git branch: master 我这里不指定用的github.io这个域名是因为我用sheldon-lu.github.io作主域名，sheldon_blog作文根，当然这样的话这边hexo内设置如下：(大概在14行左右开始) 1234567# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://sheldon-lu.github.io/root: /sheldon_blog# permalink: :year/:month/:day/:title/permalink: passages/:title/permalink_defaults: 至此，就可以使用了，浏览器输入域名：https://sheldon-lu.github.io/sheldon_blog即可 1、这里要说明一下，使用 hexo d 上传至github时如果需要用到 gh-pages 的话，记得在自己github的blog项目下创建个gh-pages的分支，即可; 2、_config.yml中配置repository时一定配置的要是ssh，别弄的什么https://github之类的 参考地址：https://ngwind.github.io/2018/07/27/%E4%BD%BF%E7%94%A8gh-pages+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E9%A1%B5%E6%95%99%E7%A8%8B/]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
