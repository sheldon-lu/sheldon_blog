<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Kubernetes安装-kubeadm1.13.5(非外部etcd)]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2FKubernetes%E5%AE%89%E8%A3%85-kubeadm1-13-5-%E9%9D%9E%E5%A4%96%E9%83%A8etcd%2F</url>
    <content type="text"><![CDATA[之前写过一篇kubernetes安装的，用到的是外部的etcd，即etcd单独二进制安装，kubeadm初始化指定即可； 本篇用的纯kubeadm安装高可用集群，master组件静态pod 环境描述 kubernetes version：1.13.5 docker version：18.6.3 Redhat：7.6 x.x.x.1 master-1 kube-apiserver、kube-controller-manager、kube-scheduler、etcd、keepalive、docker x.x.x.2 master-2 kube-apiserver、kube-controller-manager、kube-scheduler、etcd、keepalive、docker x.x.x.3 master-3 kube-apiserver、kube-controller-manager、kube-scheduler、etcd、keepalive、docker x.x.x.4 vip x.x.x.5 node-1 kubelet、docker x.x.x.6 node-2 kubelet、docker 因为担心kubeadm起来的etcd不稳定，这里用到的etcd对于kubernetes来说作为外部etcd集群。即使用二进制安装etcd集群，其余组件用kubeadm来完成安装。 环境准备1、准备工作12345678910111213141516echo "1" &gt; /proc/sys/net/bridge/bridge-nf-call-iptables# 停防火墙systemctl stop firewalldsystemctl disable firewalldsystemctl disable firewalld# 关闭Swapswapoff -ased 's/.*swap.*/#&amp;/' /etc/fstab# 关闭防火墙systemctl disable firewalld &amp;&amp; systemctl stop firewalld &amp;&amp; systemctl status firewalld# 关闭Selinuxsetenforce 0sed -i "s/^SELINUX=enforcing/SELINUX=disabled/g" /etc/sysconfig/selinuxsed -i "s/^SELINUX=enforcing/SELINUX=disabled/g" /etc/selinux/configsed -i "s/^SELINUX=permissive/SELINUX=disabled/g" /etc/sysconfig/selinuxsed -i "s/^SELINUX=permissive/SELINUX=disabled/g" /etc/selinux/config 2、docker安装1、下载设置源123sudo yum install -y yum-utils \ device-mapper-persistent-data \ lvm2 123yum-config-manager \--add-repo \https://download.daocloud.io/docker/linux/centos/docker-ce.repo 2、安装docker123yum list docker-ce --showduplicates | sort -r # 列出docker-ce的版本listyum install docker-ce-&lt;版本号&gt; -y # -y 安装docker需要的依赖，其中有个container-selinux的也可以单独下载# rpm -ivh container-selinux-2.33-1.git86f33cd.el7.noarch.rpm 3、启动docker12systemctl start dockerdocker version # 验证docker安装是否完成并启动成功 3、kubeadm/kubelet/kubectl安装 各节点安装 1234567891011121314cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOFyum install -y kubelet-1.13.5 kubeadm-1.13.5 kubectl-1.13.5 --disableexcludes=kubernetes #禁用除kubernetes之外的仓库,要用 -y 参数，会自动安装kube-cni等插件systemctl start kubeletsystemctl enable kubelet # kubeadm 要求kubelet保持开机自启状态 4、keepalive安装 master节点安装： 123456789101112131415161718192021222324252627282930313233343536373839404142yum install -y keepalivedsystemctl start keepalivedvim /etc/keepalived/keepalived.confglobal_defs &#123; router_id LVS_k8s&#125;vrrp_script CheckK8sMaster &#123; script &quot;curl -k https://10.70.49.130:6443&quot; interval 3 timeout 9 fall 2 rise 2&#125;vrrp_instance VI_1 &#123; state MASTER interface ens256 # 网卡 virtual_router_id 61 # 主节点权重最高 依次减少 priority 120 advert_int 1 #修改为本地IP mcast_src_ip x.x.x.2 nopreempt authentication &#123; auth_type PASS auth_pass sqP05dQgMSlzrxHj &#125; unicast_peer &#123; x.x.x.1 #x.x.x.2 x.x.x.3 &#125; virtual_ipaddress &#123; x.x.x.4 &#125; track_script &#123; CheckK8sMaster &#125;&#125; kubernetes部署1、master部署 部署之前请确保下载好相关image，翻墙下载或者国内dockerhub下载kubernetes镜像 1、初始化master1 创建master1的初始化配置文件,网络插件采用flannel，CIDR地址是 “10.244.0.0/16”，如下为1.13.5新版本配置文件。 1234567891011121314151617181920212223242526272829303132cat &gt; kubeadm-master.yaml &lt;&lt; EOFapiVersion: kubeadm.k8s.io/v1beta1kind: InitConfigurationnodeRegistration: name: 10.78.229.193 # 指定node name，kubectl get no会显示iplocalAPIEndpoint: advertiseAddress: x.x.x.1 # 本机ip，这里为x.x.x.1-3 bindPort: 6443---apiVersion: kubeadm.k8s.io/v1beta1kind: ClusterConfigurationkubernetesVersion: v1.13.5 # kubernetes版本 对应下载的imageimageRepository: k8s.gcr.io # 自己修改为自己的镜像库名apiServer: certSANs: - "master1" - "master2" - "master3" - "x.x.x.1" - "x.x.x.2" - "x.x.x.3" - "x.x.x.4" - "127.0.0.1"controlPlaneEndpoint: "x.x.x.4:8443" # 控制台ip指定，即vip 实现apiserver高可用etcd: local: dataDir: /var/lib/etcd # 随意指定即可networking: podSubnet: "10.244.0.0/16"EOF 123# 运行初始化命令即可，前提要把相关设置关闭，详情至准备工作# 其中在kubelet配置里加入--pod-infra-container-image 参数指定 pause私有镜像库镜像kubeadm init --config kubeadm-master.yaml 在初始化配置里，对于etcd有两种高可用的选项，一个使用内部etcd，一个使用外部etcd(独立搭建的etcd集群，而不是在初始化中搭建的)，两者初始化配置文件略有不同。 1234567891011121314151617# 使用内部etcd的话，初始化yaml文件中etcd配置如下：etcd: local: extraArgs: listen-client-urls: "https://127.0.0.1:2379,https://x.x.x.x:2379" advertise-client-urls: "https://x.x.x.x:2379" listen-peer-urls: "https://x.x.x.x:2380" initial-advertise-peer-urls: "https://x.x.x.x:2380" initial-cluster: "master1.hanli.com=https://x.x.x.x:2380"# 使用外部etcd的话，etcd: #ETCD的地址 external: endpoints: - https://x.x.x.1:2379 - https://x.x.x.2:2379 - https://x.x.x.3:2379 init初始化之后，如果成功会出现join，这时就可以运行一下命令 机器上的用户要使用kubectl来管理集群操作集群 123mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config 验证命令 123456789kubectl get cs # 如下信息NAME STATUS MESSAGE ERRORcontroller-manager Healthy okscheduler Healthy oketcd-0 Healthy &#123;"health": "true"&#125;kubectl get node # notReady 状态，是因为没有安装网络插件 Name成ip，可修改kubelet的启动参数即可NAME STATUS ROLES AGE VERSIONmaster1 NotReady master 1m v1.13.5 2、启动flannel服务123456789101112wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml# flannel 默认会使用主机的第一张网卡，如果你有多张网卡，需要通过配置单独指定。修改 kube-flannel.yml 中的以下部分cat kube-flannel.yml containers: - name: kube-flannel image: quay.io/coreos/flannel:v0.11.0-amd64 # 修改下自己私有镜像库的flannel镜像名 command: - /opt/bin/flanneld args: - --ip-masq - --kube-subnet-mgr - --iface=ens33 #添加 1234567891011121314kubectl apply -f kube-flannel.yml # 创建pod，因为是ds的所以后续集群里面加节点就会自动启动flannelkubectl get node # 会发现 node状态变成了 ReadyNAME STATUS ROLES AGE VERSIONmaster1 Ready master 10m v1.13.5kubectl get po --all-namespacesNAMESPACE NAME READY STATUS RESTARTS AGEkube-system coredns-86c58d9df4-r59rv 1/1 Running 0 59mkube-system coredns-86c58d9df4-rbzx5 1/1 Running 0 59mkube-system kube-apiserver-master1 1/1 Running 0 58mkube-system kube-controller-manager-master1 1/1 Running 16 58mkube-system kube-flannel-ds-amd64-229j2 1/1 Running 0 42mkube-system kube-proxy-4wrg5 1/1 Running 0 59mkube-system kube-scheduler-master1 1/1 Running 13 58m 不是running状态，就说明出错了，通过查看 描述：kubectl describe pod kube-scheduler-master.hanli.com -n kube-system 日志：kubectl logs kube-scheduler-master.hanli.com -n kube-system flannel服务启动成功后，coredns也就会自动启动成功，状态为Running 3、初始化其他master节点 首先把master1上生成的ca证书等，拷贝到其他master节点上，最好免密，可使用pscp等批量任务 123456789101112131415161718192021&gt; #!/bin/bash&gt; #注意修改为自己的主机名&gt; export CONTROL_PLANE_IPS="master2 master3" &gt; &gt; # 保证节点有/etc/kubernetes/pki目录&gt; # 把以下证书复制到其他master节点&gt; for host in $&#123;CONTROL_PLANE_IPS&#125;; do&gt; # ！！！修正拷贝证书的时候请指定特定证书拷贝（之前的已经备注，新加的有etcd目录，没有用外部etcd集群），因为在证书拷贝的情况下吃过亏，因此修改此处！！！&gt; # 附issue：https://github.com/kubernetes/kubeadm/issues/1321 &gt; # 找了好久终于！！！哭&gt; #scp /etc/kubernetes/pki/*.crt $host:/etc/kubernetes/pki/&gt; #scp /etc/kubernetes/pki/*.key $host:/etc/kubernetes/pki/&gt; #scp /etc/kubernetes/pki/*.pub $host:/etc/kubernetes/pki/&gt; #scp /etc/kubernetes/admin.conf $host:/etc/kubernetes/admin.conf&gt; scp /etc/kubernetes/pki/ca.* "$&#123;USER&#125;"@$host:/etc/kubernetes/pki/&gt; scp /etc/kubernetes/pki/sa.* "$&#123;USER&#125;"@$host:/etc/kubernetes/pki/&gt; scp /etc/kubernetes/pki/front-proxy-ca.* "$&#123;USER&#125;"@$host:/etc/kubernetes/pki/&gt; scp /etc/kubernetes/pki/etcd/ca.* "$&#123;USER&#125;"@$host:/etc/kubernetes/pki/etcd/&gt; scp /etc/kubernetes/admin.conf "$&#123;USER&#125;"@$host:/etc/kubernetes/&gt; done&gt; 1234567891011121314151617&gt; tree /etc/kubernetes/pki/&gt; /etc/kubernetes/pki/&gt; ├── apiserver.crt&gt; ├── apiserver-etcd-client.crt&gt; ├── apiserver-etcd-client.key&gt; ├── apiserver.key&gt; ├── apiserver-kubelet-client.crt&gt; ├── apiserver-kubelet-client.key&gt; ├── ca.crt&gt; ├── ca.key&gt; ├── front-proxy-ca.crt&gt; ├── front-proxy-ca.key&gt; ├── front-proxy-client.crt&gt; ├── front-proxy-client.key&gt; ├── sa.key&gt; └── sa.pub&gt; 123456789101112131415161718192021222324252627282930# 分别修改对应ip 参数`--node-name`，在在master2、3执行master1出现的join命令即可 步骤如下：# 对于控制平面node 增加 `--experimental-control-plane` 即可，只有master node采用，更方便。当然还有复杂的通过原子操作来add etcd node 增加 etcd-clusterkubeadm join x.x.x.4:8443 --token bnnsb7.amapp1t78llxn54d --discovery-token-ca-cert-hash sha256:520ef89be84c30e480db6d441a7e4179634a9455f0009e249ebe8f35fa792087 --experimental-control-plane --node-name=x.x.x.2#(对应主机ip) # 等待kube-proxy flannel启动成功即可# 这种方案，kubectl get cs直观的看不到etcd集群的，可通过一下命令：kubectl exec -n kube-system etcd-x.x.x.1 -- etcdctl --ca-file /etc/kubernetes/pki/etcd/ca.crt --cert-file /etc/kubernetes/pki/etcd/peer.crt --key-file /etc/kubernetes/pki/etcd/peer.key --endpoints=https://x.x.x.1:2379 member list# 这里把master2、3节点采用原子操作加入etcd集群步骤写下来：# 配置证书kubeadm init phase certs all --config kubernetes.yaml # etcd证书kubeadm init phase etcd local --config kubernetes.yaml # 生成kubelet配置文件kubeadm init phase kubeconfig kubelet --config kubernetes.yaml # 启动kubeletkubeadm init phase kubelet-start --config kubernetes.yaml # 配置kubectl命令mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config# etcd集群加节点kubectl exec -n kube-system etcd-x.x.x.1 -- etcdctl --ca-file /etc/kubernetes/pki/etcd/ca.crt --cert-file /etc/kubernetes/pki/etcd/peer.crt --key-file /etc/kubernetes/pki/etcd/peer.key --endpoints=https://x.x.x.1:2379 member add etcd2 https://x.x.x.2:2380# 启动 kube-apiserver、kube-controller-manager、kube-schedulerkubeadm init phase kubeconfig all --config kubernetes.yamlkubeadm init phase control-plane all --config kubernetes.yaml# 标记masterkubeadm init phase mark-control-plane --config kubernetes.yaml 1234567891011121314151617181920kubectl get po -n kube-systemNAME READY STATUS RESTARTS AGEcoredns-9f9d9c76-4zrt4 1/1 Running 0 2dcoredns-9f9d9c76-dqd4c 1/1 Running 0 2dkube-apiserver-zjjh-rq-k8s-1 1/1 Running 0 2dkube-apiserver-zjjh-rq-k8s-2 1/1 Running 0 2dkube-apiserver-zjjh-rq-k8s-3 1/1 Running 0 2dkube-controller-manager-zjjh-rq-k8s-1 1/1 Running 0 2dkube-controller-manager-zjjh-rq-k8s-2 1/1 Running 0 2dkube-controller-manager-zjjh-rq-k8s-3 1/1 Running 0 2dkube-flannel-ds-amd64-7ghn7 1/1 Running 1 2dkube-flannel-ds-amd64-9cqts 1/1 Running 0 2dkube-flannel-ds-amd64-f57nh 1/1 Running 1 2dkube-proxy-8fwts 1/1 Running 0 2dkube-proxy-95tjb 1/1 Running 0 2dkube-proxy-bls94 1/1 Running 0 2dkube-scheduler-zjjh-rq-k8s-1 1/1 Running 0 2dkube-scheduler-zjjh-rq-k8s-2 1/1 Running 0 2dkube-scheduler-zjjh-rq-k8s-3 1/1 Running 0 2dkubernetes-dashboard-67d49f7868-x79wf 1/1 Running 0 76m 2、Work节点加入集群 输入master节点初始化成功之后出现的join命令，出现kubectl get nodes即成功 12&gt; kubeadm join x.x.x.4:8443 --token bnnsb7.amapp1t78llxn54d --discovery-token-ca-cert-hash sha256:520ef89be84c30e480db6d441a7e4179634a9455f0009e249ebe8f35fa792087&gt; 3、集群验证1234567891011121314151617181920# 节点状态[root@master] ~$ kubectl get nodes# 组件状态[root@master] ~$ kubectl get cs# 服务账户[root@master] ~$ kubectl get serviceaccount# 集群信息[root@master] ~$ kubectl cluster-info# 验证dns功能[root@master] ~$ kubectl run curl --image=radial/busyboxplus:curl -it[ root@curl-66959f6557-r4crd:/ ]$ nslookup kubernetes.defaultServer: 10.96.0.10Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.localName: kubernetes.defaultAddress 1: 10.96.0.1 kubernetes.default.svc.cluster.local 附录： 打算把以前kubernetes二进制安装的步骤，也迁过来。kubeadm已经GA，之后也会一直用kubeadm了 kubeadm token create --print-join-command可以获取 kubeadm join命令，比以前真的方便很多了 =。= 12&gt; # kubelet.service配置文件 /use/lib/systemd/system/kubelet.service.d/10-kubeadm.conf&gt; 参考链接： kubeadm安装1.13.5：https://blog.csdn.net/fanren224/article/details/86573264#2master1_165 二进制安装：https://github.com/mritd/ktool 二进制安装kubernetes_v1.13.4：https://mritd.me/2019/03/16/set-up-kubernetes-1.13.4-cluster/]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>Kubernetes_ha</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_set集合操作]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2FPython-set%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Python_set集合类型小结下面来点简单的小例子说明把。 1234x = set('spam')y = set(['h','a','m'])x, y(set(['a', 'p', 's', 'm']), set(['a', 'h', 'm'])) 再来些小应用。 12345678&gt; &gt; &gt; x &amp; y # 交集&gt; &gt; &gt; set(['a', 'm'])&gt; &gt; &gt; x | y # 并集&gt; &gt; &gt; set(['a', 'p', 's', 'h', 'm'])&gt; &gt; &gt; x - y # 差集&gt; &gt; &gt; set(['p', 's']) 记得以前个网友提问怎么去除海量列表里重复元素，用hash来解决也行，只不过感觉在性能上不是很高，用set解决还是很不错的，示例如下： 1234567a = [11,22,33,44,11,22]b = set(a)bset([33, 11, 44, 22])c = [i for i in b]c[33, 11, 44, 22] 很酷把，几行就可以搞定。 集合集合用于包含一组无序的对象。要创建集合，可使用set()函数并像下面这样提供一系列的项： 12s = set([3,5,9,10]) #创建一个数值集合t = set("Hello") #创建一个唯一字符的集合 与列表和元组不同，集合是无序的，也无法通过数字进行索引。此外，集合中的元素不能重复。例如，如果检查前面代码中t集合的值，结果会是: 12&gt; &gt; &gt; tset(['H', 'e', 'l', 'o']) 注意只出现了一个’l’。 集合支持一系列标准操作，包括并集、交集、差集和对称差集，例如： 1234a = t | s # t 和 s的并集b = t &amp; s # t 和 s的交集c = t – s # 求差集（项在t中，但不在s中）d = t ^ s # 对称差集（项在t或s中，但不会同时出现在二者中） 基本操作： 123t.add('x') # 添加一项s.update([10,37,42]) # 在s中添加多项 1234567891011121314151617181920212223242526272829303132333435363738t.remove('H')# 使用remove()可以删除一项：len(s)# set 的长度x in s# 测试 x 是否是 s 的成员x not in s# 测试 x 是否不是 s 的成员s.issubset(t)s &lt;= t# 测试是否 s 中的每一个元素都在 t 中s.issuperset(t)s &gt;= t# 测试是否 t 中的每一个元素都在 s 中s.union(t)s | t# 返回一个新的 set 包含 s 和 t 中的每一个元素s.intersection(t)s &amp; t# 返回一个新的 set 包含 s 和 t 中的公共元素s.difference(t)s - t# 返回一个新的 set 包含 s 中有但是 t 中没有的元素s.symmetric_difference(t)s ^ t# 返回一个新的 set 包含 s 和 t 中不重复的元素s.copy()# 返回 set “s”的一个浅复制 请注意：union(), intersection(), difference() 和 symmetric_difference() 的非运算符（non-operator，就是形如 s.union()这样的）版本将会接受任何 iterable 作为参数。相反，它们的运算符版本（operator based counterparts）要求参数必须是 sets。这样可以避免潜在的错误，如：为了更可读而使用 set(‘abc’) &amp; ‘cbs’ 来替代 set(‘abc’).intersection(‘cbs’)。从 2.3.1 版本中做的更改：以前所有参数都必须是 sets。 另外，Set 和 ImmutableSet 两者都支持 set 与 set 之间的比较。两个 sets 在也只有在这种情况下是相等的：每一个 set 中的元素都是另一个中的元素（二者互为subset）。一个 set 比另一个 set 小，只有在第一个 set 是第二个 set 的 subset 时（是一个 subset，但是并不相等）。一个 set 比另一个 set 打，只有在第一个 set 是第二个 set 的 superset 时（是一个 superset，但是并不相等） 子 set 和相等比较并不产生完整的排序功能。例如：任意两个 sets 都不相等也不互为子 set，因此以下的运算都会返回 False：a&lt;b, a==b, 或者a&gt;b。因此，sets 不提供 cmp 方法。 运算符123456789101112131415161718192021222324252627282930313233hash(s)# 返回 s 的 hash 值s.update(t)s |= t# 返回增加了 set “t”中元素后的 set “s”s.intersection_update(t)s &amp;= t# 返回只保留含有 set “t”中元素的 set “s”s.difference_update(t)s -= t# 返回删除了 set “t”中含有的元素后的 set “s”s.symmetric_difference_update(t)s ^= t# 返回含有 set “t”或者 set “s”中有而不是两者都有的元素的 set “s”s.add(x)# 向 set “s”中增加元素 xs.remove(x)# 从 set “s”中删除元素 x, 如果不存在则引发 KeyErrors.discard(x)# 如果在 set “s”中存在元素 x, 则删除s.pop()# 删除并且返回 set “s”中的一个不确定的元素, 如果为空则引发 KeyError，随机删除并打印s.clear()# 删除 set “s”中的所有元素 请注意：非运算符版本的 update(), intersection_update(), difference_update()和symmetric_difference_update()将会接受任意 iterable 作为参数。从 2.3.1 版本做的更改：以前所有参数都必须是 sets。 还请注意：这个模块还包含一个 union_update() 方法，它是 update() 方法的一个别名。包含这个方法是为了向后兼容。程序员们应该多使用 update() 方法，因为这个方法也被内置的 set() 和 frozenset() 类型支持。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python_碎片化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_list或dict合并]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2FPython-list%E6%88%96dict%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[对于两个list、两个dict合并数据1.两个字典：12a= &#123;'a':1,'b':2,'c':3&#125; b= &#123;'aa':11,'bb':22,'cc':33&#125; 合并1：dict(a,**b) 操作如下： 1c = dict(a,**b) 合并2：dict(a.items()+b.items()) 如下： 1c = dict(a.item() + b.items()) 合并3：c = {} c.update(a) c.update(b) 输出c 如下： 123c = &#123;&#125;c.update(a)c.update(b) 2.两个list合并：12a = [1,2,3,4,5,6] b = ['a','b','c','d'] 合并1：a+b 如下： 1c = a+b 合并2：a+=b 这时a的值变成了合并后的结果，如下： 1a += b # ====&gt; a = a+b 合并3：a.extend(b) 和+=结果一样，输出a 如下： 1a.extend(b) # a += b 合并4：a.append(b)将b看成list一个元素和a合并成一个新的list，合并后的结果输入a 如下： 1a.append(b) # list add other list &gt;&gt; [1,2,3,[1,2,3]] 合并5：a[0:0] = b 使用切片，如下： 1a[0:0] = b 附录： 123456789101112131415161718192021&gt; # 方法一：&gt; list1 = ['k1','k2','k3']&gt; list2 = ['v1','v2','v3']&gt; dic = dict(map(lambda x,y:[x,y],list1,list2))&gt; &gt;&gt;&gt; print(dic)&gt; &#123;'k3': 'v3', 'k2': 'v2', 'k1': 'v1'&#125;&gt; &gt; # 方法二：&gt; &gt;&gt;&gt; dict(zip(list1,list2))&gt; &#123;'k3': 'v3', 'k2': 'v2', 'k1': 'v1'&#125;&gt; &gt; # 方法三：&gt; &gt;&gt;&gt; l1=[1,2,3,4,5,6]&gt; &gt;&gt;&gt; l2=[4,5,6,7,8,9]&gt; &gt;&gt;&gt; &#123;k:v for k,v in zip(l1,l2)&#125;&gt; &#123;1: 4, 2: 5, 3: 6, 4: 7, 5: 8, 6: 9&#125;&gt; &gt; &gt;&gt;&gt; x = &#123;1: 4, 2: 5, 3: 6, 4: 7, 5: 8, 6: 9&#125;&gt; &gt;&gt;&gt; &#123;v:k for k,v in x.items()&#125; #反过来 将字典中的v和k调换&gt; &#123;4: 1, 5: 2, 6: 3, 7: 4, 8: 5, 9: 6&#125;&gt;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python_碎片化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_list交集、差集和并集]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2FPython-list%E4%BA%A4%E9%9B%86%E3%80%81%E5%B7%AE%E9%9B%86%E5%92%8C%E5%B9%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[举例说明 a_list = [1,2,3,4]b_list = [1,4,5] 一. 差集很明显结果是[2,3,5]，下面我们说一下具体方法。方法a.正常法： 1234ret_list = []for item in a_list: if item not in b_list: ret_list.append(item) 方法b.简化版： 1ret_list = [item for item in a_list if item not in b_list] 方法c.高级版： 1ret_list = list(set(a_list)^set(b_list)) 二. 并集很明显结果是[1,2,3,4,5],下面是具体方法： 1ret_list = list(set(a_list).union(set(b_list))) 三. 交集很明显结果是[1,4]，下面是具体方法： 1ret_list = list( ( set(a_list).union(set(b_list)) )^( set(a_list)^set(b_list) ) )]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python_碎片化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_问题小结(2)]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2FPython-%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93-2%2F</url>
    <content type="text"><![CDATA[环境：未特别注明的话，均为Python 3.6.5，IDE：VS code 遇到的都是基础问题，分了两篇。 担心一篇写多了会看不下去 『1』关于python无法显示中文的问题：SyntaxError: Non-ASCII character ‘\xe4’ in file test.py on line 3, but no encoding declared。python：2.7.15 解决办法： 在以后的每一个需要显示汉字的python文件中， 可以采用如下方法在 #!/usr/bin/python的下一行加上一句话来定义编码格式， 我以utf-8编码为例。 1234567891011### 第一种：#!/usr/bin/python#coding:utf-8### 第二种：#!/usr/bin/python#-*-coding:utf-8 -*-### 第三种：#!/usr/bin/python#vim: set fileencoding:utf-8 『2』有时候在去数据的时候会遇到数据内有中文，但是取出来的是unicode码，用了很多方法也转不了中文解决: “反编码”我自己起的名字，大概意思就是我得到一串字符，是unicode码，如：‘\u53eb\u6211’，进行反编码后得到其对应的汉字。 123f='\u53eb\u6211'print fprint(f.decode('unicode-escape'))123 结果为: 12\u53eb\u6211 叫我 『3』在编译时会出现这样的错：IndentationError:expected an indented block说明此处需要缩进，你只要在出现错误的那一行，按空格或Tab（但不能混用）键缩进就行。 『4』SyntaxError:invalid syntax ：语法错误。最常见的，最基础的错误 英文是“非法语句”的意思。漏标点符号（例如漏分号，漏&amp;号），多标点符号，拼写错，等等都会造成这种错 『5』url连接超时解决：1）使用的是urllib不是urllib2，所以无法直接在urlopen里面加timeout参数，只能是设置全局脚本的超时时间 12import socketsocket.setdefaulttimeout(60) 设置全局的超时时间为60s。 2）urllib，urllib2常会一起使用（两者分别提供不同的功能） 1234html = urllib.urlopen(url).read()# 修改为import urllib2html = urllib2.urlopen(url, timeout=60).read() 『6』UnboundLocalError: local variable ‘appname’ referenced before assignment：123456&#123;u&apos;batchrealnameverifytask&apos;: 99.41, u&apos;bptask100000188408&apos;: 98.77, u&apos;clsexpflowmaintask576&apos;: 101.28&#125;Traceback (most recent call last): File &quot;get_app_cpu_from_influxdb.py&quot;, line 89, in &lt;module&gt; appname = get_sql_info(key) File &quot;get_app_cpu_from_influxdb.py&quot;, line 28, in get_sql_info return appname 变量问题：变量在被赋值之前被使用定义 『7』TypeError: sequence item 1: expected string or Unicode, NoneType found期望值未发现：str或者unicode类型 12345message = u"应用的CPU利用率超过%s,请检查应用:%s"%(str(threshold)+'%',",".join(app_name))# =====================&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;message = "应用的CPU利用率超过%s,请检查应用:%s"%(str(threshold)+'%',",".join(app_name)) 『8』UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xe5 in position 1: ordinal not in range(128)1234# 关于编码问题：import sysreload(sys)sys.setdefaultencoding( "utf-8" ) 『9』IndentationError: unindent does not match any outer indentation level【问题】 一个python脚本，本来都运行好好的，然后写了几行代码，而且也都确保每行都对齐了，但是运行的时候，却出现语法错误： 1IndentationError: unindent does not match any outer indentation level 【解决过程】 1.对于此错误，最常见的原因是，的确没有对齐。但是我根据错误提示的行数，去代码中看了下，没啥问题啊。 都是用TAB键，对齐好了的，没有不对齐的行数啊。 2.以为是前面的注释的内容影响后面的语句的语法了，所以把前面的注释也删除了。 结果还是此语法错误。 3.后来折腾了半天，突然想到了，把当前python脚本的所有字符都显示出来看看有没有啥特殊的字符。tab与空格混用了 『10』request https报错：12# 忽略警告：InsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verification is strongly advised.requests.packages.urllib3.disable_warnings(） 『11』python安装MySQLdb的时候一直有问题在Linux下 1pip install MySQL-python 如果安装之后仍不能正常运行，尝试用yum install MySQL-python，因为这个模块需要一些第三方程序来运行的。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python_problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_问题小结(1)]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2FPython-%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93-1%2F</url>
    <content type="text"><![CDATA[环境：未特别注明的话，均为Python 3.6.5，IDE：VS code 『1』TypeError: unbound method 问题今天执行了下之前写的Python接口文件，源码如下: 12345678910__author__ = 'Administrator'#coding:utf-8from readData import dictionaryreadIt = &#123;&#125;readIt = dictionary.onlyCellValue("E:\python\API\eadData.xls", "Sheet1", 1)print readItfor key in readIt: temp_list = readIt[key] for i in range(0, len(temp_list)): print "第"+(i+1)+"个参数为"+temp_list[i] 在运行时报错：TypeError: unbound method onlyCellValue() must be called with dictionary instance as first argument (got str instance instead)，后经在网上查看，发现时由于调用其他类时，未在后面添加括号，添加括号后，运行正常。这是由于未添加括号情况下，未被认为是类的实例，故报此错； 改正后的：readIt = dictionary().onlyCellValue(“E:\python\API\eadData.xls”, “Sheet1”, 1) 『2』Python访问MySQL听说很多人都使用著名的MySQLdb来访问MySQL(当然还有pymysql)，但是它并不支持Python 3.x的版本。所以要另寻出路。那就是mysql-connector-python，这个貌似是MySQL官方提供的，并且它不依赖于MySQL C客户端library，我下载的是1.1.4版本，下载解压之后，会看到setup.py文件，这样安装： 1sudo python3.2 setup.py install 然后在程序中就可以用了。下面给出一段查询MySQL记录的示例代码： 1234567891011121314151617181920212223242526272829303132import mysql.connectorimport sys __author__ = 'codelast' username = 'root'password = 'xxx'host = '127.0.0.1'db = 'mydb' connection = mysql.connector.connect(user=username, password=password, host=host, database=db)cursor = connection.cursor() sql = "SELECT * FROM my_table WHERE id = 9"try: cursor.execute(sql) # 打印查询到的记录的行数 data = cursor.fetchall() print(len(data)) # 输出所有记录 for (ID, name) in data: print("name:[%s]" % (name)) except mysql.connector.Error as err: print("Failed to query table, detail: &#123;&#125;".format(err.msg)) sys.exit() connection.commit()cursor.close()connection.close() 上面的代码很简单，无非就是从my_table表里查询一些记录，再打印出来。注意 for (ID, name) 中的括号里要写全该表中，你查询的所有字段名，否则会报错。还有其他遍历查询结果的方法，后面会继续陈述。 『3』逆序遍历list123myList = [1, 2, 3]for item in reversed(myList): print(item) 输出： 123321 注意是 reversed 不是 reverse。这只是逆序遍历，myList中的数据顺序并不会改变。 『4』使用MySQLdb访问数据库时，“TypeError: execute() takes at most 3 arguments (4 given)”错误的解决办法Python版本：2.7.3使用2.7.3版本的Python时，访问MySQL的最佳方案应该数使用MySQLdb了。如果在执行SQL时，你遇到了上面所说的问题，那么你可能是像下面这样写导致的： 12sql = "INSERT INTO my_table (field1, field2) VALUES (%s, %s)"cursor.execute(sql, "a", "b") 这是错误的，其实这货根本不是这样用的，当参数多于一个时，你要把它们放在一个tuple里传进去： 12sql = "INSERT INTO my_table (field1, field2) VALUES (%s, %s)"cursor.execute(sql, ("a", "b")) 例如这个链接有个例子。 『5』使用 lxml 库生成XML（字符串）Python版本：2.7.3直接看代码： 12345678910111213141516171819202122232425#coding:UTF-8"""XML生成器。文件名：xmlGenerator.py""" __author__ = 'Darran Zhang @ codelast.com' from lxml import etree class XMLGenerator: def __init__(self): pass def generate_xml(self): commands = etree.Element('Commands') command = etree.SubElement(commands, 'Command') from_user = etree.SubElement(command, 'FromUser') from_user.text = u'abc' cmd = etree.SubElement(command, 'Cmd') cmd.text = u'mmmmmmmmmmmmmm' cmd_extra_data = etree.SubElement(command, 'CmdExtraData') cmd_extra_data.text = u'eeeeeeeeee' return etree.tostring(commands, pretty_print=True, xml_declaration=True, encoding='utf-8') 测试代码： 1234from xmlGenerator import XMLGenerator xmlGen = XMLGenerator()print(xmlGen.generate_xml()) 12345678&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;&lt;Commands&gt; &lt;Command&gt; &lt;FromUser&gt;abc&lt;/FromUser&gt; &lt;Cmd&gt;mmmmmmmmmmmmmm&lt;/Cmd&gt; &lt;CmdExtraData&gt;eeeeeeeeee&lt;/CmdExtraData&gt; &lt;/Command&gt;&lt;/Commands&gt; 可见非常简单。 『6』在PyCharm中无法安装MySQL-python这个package的一个解决办法在PyCharm中可以直接搜索Python package并安装，我遇到的一个问题是：无法安装，错误提示的其中一段为： EnvironmentError: mysql_config not found 你需要保证你的Ubuntu已经安装了以下这些东西： 1sudo apt-get install mysql-server mysql-client libmysqlclient-dev 然后再试，一切OK。 『7』”ValueError: zero length field name in format”错误的解决办法Python版本：2.6.6错误出在如下语句： 1"&#123;&#125;\t&#123;&#125;".format(123, 456) 我遇到的出问题的Python版本为2.6.6（不知道是不是2.6.*及低版本都有此问题），反正Python 2.7.3就没有这个问题了。上面的代码无非主就是把123和456代替两个大括号。在旧版本的Python上（具体从哪个版本开始不用这样写，我不确定），你要有多个需要format的field时，需要指定它们的顺序： 1"&#123;0&#125;\t&#123;1&#125;".format(123, 456) 这样就没问题了。 『8』对一个字典(dict)，按value进行排序Python版本：2.6.6，2.6.9均测试可用（Python3里没有cmp方法了，所以不能用） 123sortedList = sorted(myDict.items(), lambda x, y: cmp(x[1], y[1]), reverse=True)for (k, v) in sortedList: print("&#123;0&#125;\t&#123;1&#125;".format(k,v)) 其中，myDict是你要将其排序的字典，sortedList是排序之后的结果，变成了一个list，里面是若干个tuple，每个tuple里是一对(key,value)，所以后面用那样的方式对它进行了遍历。 『9』判断一个字典（dict）中是否包含指定的key12345678910d = dict()# 向字典中添加两个元素d[1] = 'abc'd[2] = 'def' # 检查 3 这个key是否在字典中，结果输出的是“NO”if 3 in d: print('YES')else: print('NO') 『10』Python正则简单示例先看代码： 12345code = 'String url = "http://item.jd.com/1148104.html?erpad_source=abc";'pattern = re.compile('.*\"(.*)\"')match = pattern.match(code)if match: print(match.group(1)) 输出： 1http://item.jd.com/1148104.html?erpad_source=abc 说明：上面的代码是想把字符串“code”中的双引号里的那个URL打印出来。正则表达式 .\”(.)\” 中的小括号就是第1个group，匹配上的话可以用 group(1) 获取之。 『11』try…except的示例参考123456try: # 可能会出现异常的一段代码 command_1 # 如果command_1出现异常，则不执行command_1以及之后的语句 command_2 # command_1如果正常，则会执行except: # try中任意一行语句出现异常，直接跳转至except，程序继续运行 command_3 command_4 『』To be added…]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python_problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker的问题总结]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2FDocker%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[问题：1、Docker18.06.1-ce安装(RHEL7)后启动失败, 原因(xfsprogs版本过低)* 问题分析: 使用/usr/bin/dockerd启动测试发现是文件系统无法创建 1 WARN[2018-09-15T10:47:39.886191433+08:00] Usage of loopback devices is strongly discouraged for production use. Please use --storage-opt dm.thinpooldev or use man dockerd to refer to dm.thinpooldev section. storage-driver=devicemapper 2 INFO[2018-09-15T10:47:40.220046362+08:00] Creating filesystem xfs on device docker-253:4-17133027-base, mkfs args: [-m crc=0,finobt=0 /dev/mapper/docker-253:4-17133027-base] storage-driver=devicemapper 3 INFO[2018-09-15T10:47:40.221230038+08:00] Error while creating filesystem xfs on device docker-253:4-17133027-base: exit status 1 storage-driver=devicemapper 4 ERRO[2018-09-15T10:47:40.221258767+08:00] [graphdriver] prior storage driver devicemapper failed: exit status 1 5 Error starting daemon: error initializing graphdriver: exit status 1 第三行日志可以找到mkfs的执行参数, 执行发现参数不正确 1 2 INFO[2018-09-15T10:47:40.220046362+08:00] Creating filesystem xfs on device docker-253:4-17133027-base, mkfs args: [-m crc=0,finobt=0 /dev/mapper/docker-253:4-17133027-base] storage-driver=devicemapper * 解决问题 1234yum install xfsprogs # 但是内核版本过低，操作系统7.0# 18.06最好升级系统版本到7.4，只能装会1.12版本,问题来了，私有镜像库登入不了# 17.12.0兼容 2、docker rm container 失败现象： docker version：17.12.0-ce 偶尔出现docker跟daemon守护进程失去联系 docker rm不掉容器 解决方法：docker守护进程重启了，现在只能重启解决 链接： https://github.com/moby/moby/issues/36002 3、指北：一、 原因：版本不兼容 7.2版本 升级系统7.4可解决 二、no matching entries in passwd file 进不去容器 重启docker 三、standard_init_linux.go:195: exec user process caused “exec format error” 进不去容器； 启动脚本错误 启动脚本=======》 #！/bin/bash 四、内核：enterd disabled state 被禁用状态 主机内核有问题]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Docker_problem</tag>
        <tag>Docker的一些东西</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安静写点东西]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2F%E5%AE%89%E9%9D%99%E5%86%99%E7%82%B9%E4%B8%9C%E8%A5%BF%2F</url>
    <content type="text"><![CDATA[Come on ٩(๑.◡.๑)۶ ，Please ecter Password (*ﾉ▽ﾉ). Incorrect Password! No content to display! U2FsdGVkX1+/AEplbMtkSZDhd1c+1i0FWYY1IUc0WH03egLd0mqMN4xKVVGcgkbDttY3TDx6+91z44uOEQ0BU3sMc1qW6EJyV6kMDJl/GcVseKhdYSLlUeT4UpLK5eIqIXaIme+uj8MsseSEW3jkcNKg/z5SMoMsYR7stvOovpstvp0U+ssXCSU7VvT5oa+8oQSihClq2cyi53CcK2uRhUdwuKsxeJyYsx9MTnMLnVdfu9vvQHBjxP+kP1J4VogqBZGi0vi0lxdS2qmegOMYAb34PmnXpqpr0ngMP9ZkvbxP0fcc1JWIz8O4ktJBk9vf/qZf6N1EjM4IWeGlocZF/mjimlVnSQbcFSlpGKBXJjMI5kVp5rwB8mmBXe0q+MuAtKxVQNxZ4HnMO4tsQTB9zlYzvE/DZzVDeC5AC727Ya0TSyUKNNYpycTkXlSyWUfx2NeeE0pEX+qPfXZ1xqmzNJ9PMQAp7W/tPoMBRQpHNeMzaIRDUYyRghRtrHtpsNte6PWXSRwe9xt0hUDYkmN/lq5G1DM3xlmJmVRKMT7aCJj8T1dWm6FTdVz7deaOed2ov2iVKsV+SqOQ/cTROlCCGfbL/whsWo4O3d3UeKXK5JL1sVbuAy4w3Mnkcjy8fQa3OVt+6h0cfv73zk9935kS6h6j2cxlxkfIlm3w4yhQ1HF7vyfRas+NFTdRM5q3CLiXzphfNOP5onr7JJKPTtmHBMeIa0PqQ8jW2e1wuk77FrE2SFEjUG35kMPl8p6pmhKADCjJOnSGK5eDO1JPTD9jS5DMSKXq86Qaj22soiSLV5eOinVzldQpY1V53ECdLPzROb4SpKYg2bFCMdh7e3kuJxaGAznK8SflZQXkzVCHVEYvDgLvcE+t9Oe2jVqY/Ohr1wr3F+QhH5Sonqdeszlh87wzN5gPC4Z5UhBcrGlfP1V3lLXMh4MwItIXJUdHl70YdnHlOG1Kyo0WkuMKeYWZN9u8nnJc/DmEqO/26ZjWedmybZ6Ba7kO7h9bxImtlJLvjIhDXF0QU51RVSEX41BurbN2IYADROD6g43focEzh/Br+pysqhTsXAS6xZO6UXBneIdRTJi8VyfIpeSvcJfeHDSZNm9/T/OmbLmwbBRgkiWqSoKQc+vN5FeJ0pjrXSdjR0BIMfCfX7mbN6NpTkULqABSXe7D3L7dPXaRqzrf2dy5ng/ne5+1lL/epa8tV6uOSSBrxdcT9LPq63AEMl9S8RizMdJe3ykALmhpJIdrmnNAZ5xkgJLs5PV+LBQtx6/X5Jj6nR/Z9lk+0s6P1jYT8Am+9j9L0WvhTPJgDZQ1GSl5GlbMH8hfbr6ejJCMYMjQaA56NV5zic7Lfw+Ln5HJWnLkuxarcgdvA0ycKE762+Csf4sJGkvx2HszzhgRfmbRFx/K8k5ZbCrdeYfSppexn1/oNlrtGV0kh+IZB74jbSrlAc7ji/3VxF0WcD1YZW8Z1O38YsDfzSztFi0D5BfG4vKghf4a6Mk7j4mrV8CR4FUFA2QCnGX1ZHmhgH0RGI+mr2cbk9sudpVQeoXfTeeDarGML6bX4IHCNKPaCPiZ5lHd1PWZ7O1yqyOrVaFsCogghLy1Br83OEo4BXBNSFvhIJU78V3KKnIm0QDBlE8/tMmXSIvLw7KupLqmTZDrHcuwB332NlSWhQLvVl7BZ+PgwYaqvyRgF2xesvNO8XZijJ0h5AWCYf7n3y6UM2yAyyz8Z+LYb7GVEuNcbcWLu85joy4aEIHL6XgiEgqSHCUfpHegfQSa4wf7+zLVO/QxmUWpGynZK8Dy2HO0G2rtyidFGK8DLLjfspXrKUyhCKyxQiHGY019y6JGHovJco7FFu/xU6iiTyfeURgNzDqxAXxDCcalSQyzFaUwHU93HTTuBvlLEFRj7HsBBOJIVrvZNmUw9mlkHjSOCWgmnic7t9SFdZIMODb9mSzz7mWXsxSvGGeHlq6iEE8SjPhvgPe6E3p/5+iOU0X/96/K3ZAk9OnIlpKsj7Q11OuHQs/kl6agq0jqhT7CHSg/fK2CuU7bX1BZKWzAVPYmIGBmZaSM67skOZ5sLvfAnO39x1w+R3iDz66ImdQZlhWfQFJ33IVWDdAJvND9oH8o1qjZUZSfG4/XouP+71VcdN03lDujwVViobyTzYvgoMtI4wbTc9Cv19sS0SmJl9VP/XPFAC3FmLg7f0C2/QA9jL2hJCWk1DlemPYgXTH9wmZoP91YxOnIrresqud3ksPa1Rre/QpztTIrdJFdT1x+a6W7fohA7UWRp+MiW0Sl039v+T+t1YGGRKMgRpYlogMcQ3BHpH26qVkpzPEScfF6zNshZypxMBgl3N/afEkXmwjeuEdUTy8WG2ab6o1hfUEpGM7mB4MX8cYQDAizFlYP5lJ2O3SGWcbbVeL7G3TmBCoVIt8yhDDyUtzKc+8p6h9J54xtroYuP5NDJRYPh5/41jsxJNPemCMCxscHiPMJNudGQlOptD/6npW42XBw8V6seJmeidRybBV+zT6JA/rCaRqcZtQt5sRUbTpujZIKdqWNSJi7rSmdbbV4fEQw1EAuO0Yz7qqpxBuWf2/LOW1WuWdInTYPxYFX8u6XXZMeF4BdeKp+nC4UM59GS5ITaD5aqIaRQ5VgZQDp8+z0yC0mdUNXecUhwpOEq3r1ISnNq9YH2nGM9asW7sNxYRkcgL1Y0iEoBdX1bCtfZVEfJGkrza4FzZavdiHYoukscAUIqolh5qysLmSCZjEwwk9Psnt9ztl3Ly3Jq2xY7XG1G9ulakVUbITHGTDowabxteZ3En95rP65Zpc9GkOTTYqku8TiR/fcqwWVpLE0CfQaynJdzNpJzKx4YNqbxO+NSQRdKoFdFzahKS1nT8G0pcVKwJgDMhHwZBh0J30Jf6abiplrdJHulpWM7CUCdAxEJilBQov800iSKPheFBd68FGHJY2IvdJz+DbdHXtNOYpkdT0wI5EMbkXgVJhqm258E3CJy8R+k2nbBWkn2rqC9s+c29rUnhqS7hOMA/36ZhCTS0mX5kwwWrh13zOpf7cf/XqYStbnbA85Ty7bdOK9y4L+sYeXphgUuUDtOJ8s2CielFlFwCZR76pvws4K3b8=]]></content>
      <tags>
        <tag>生活需要一点方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes_填坑]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2FKubernetes-%E5%A1%AB%E5%9D%91%2F</url>
    <content type="text"><![CDATA[更新19.4.5一、etcd 单点问题默认kubeadm创建的集群会在内部启动一个单点的 etcd，当然大部分情况下 etcd 还是很稳定的，但是一但 etcd 由于某种原因挂掉，这个问题会非常严重，会导致整个集群不可用。具体原因是 etcd 存储着 kubernetes 各种元数据信息；包括 kubectl get pod等等基础命令实际上全部是调用 RESTful API 从 etcd 中获取的信息；所以一但 etcd 挂掉以后，基本等同于kubectl命令不可用，集群各节点也会因无法从 etcd 获取数据而出现无法调度，最终挂掉。 解决办法：是在使用kubeadm创建集群时使用 –external-etcd-endpoints 参数指定外部 etcd 集群，此时kubeadm 将不会在内部创建 etcd，转而使用外部我们指定的 etcd 集群，如果外部 etcd 集群配置了 SSL 加密，那么还需要配合 –external-etcd-cafile、–external-etcd-certfile、–external-etcd-keyfile 三个参数指定 etcd 的 CA证书、CA签发的使用证书和私钥文件，命令如下 12345# 非 SSL# kubeadm init --external-etcd-endpoints http://x.x.x.1:2379# etcd SSL# kubeadm init --external-etcd-endpoints https://x.x.x.1:2379 --external-etcd-cafile /path/to/ca --external-etcd-certfile /path/to/cert --external-etcd-keyfile /path/to/privatekey 二、etcd 不可与 master 同在‘愿上帝与你同在’……这个坑是由于kubeadm的 check 机制的 bug 造成的，目前还没有修复；表现为 当 etcd 与 master 在同一节点时，kubeadm init 会失败，同时报错信息提示’已经存在了 /var/lib/etcd 目录，或者 2379 端口被占用’；因为默认kubeadm会创建 etcd，而默认的 etcd 会占用这个目录和 2379 端口，即使你加了--external-etcd-endpoints参数，kubeadm仍然会检测这两项条件是否满足，不满足则禁止 init 操作 解决办法：就是要么外部的 etcd 更换数据目录(/var/lib/etcd)和端口，要么干脆不要和 master 放在同一主机即可 三、巨大的日志熟悉的小伙伴应该清楚，基本上每个 kubernetes 组件都会有个通用的参数 --v；这个参数用于控制 kubernetes 各个组件的日志级别，在早期(alpha)的 kubeadm 版本中，如果不进行调整，默认创建集群所有组件日志级别全部为 --v=4 即最高级别输出，这会导致在业务量大的时候磁盘空间以 ‘我去尼玛’ 的速度增长，尤其是 kube-proxy 组件的容器，会疯狂吃掉你的磁盘空间，然后剩下懵逼的你不知为何。在后续的版本中(beta)发现日志级别已经降到了 --v=2，不过对于完全不怎么看日志的我来说还是无卵用…… 解决办法有两种方案: 1、如果已经 –v=4 跑起来了(检查方法就是随便 describe 一个 kube-proxy 的容器，看下 command 字段就能看到)，并且无法停止重建集群，那么最简单的办法就是使用kubectl edit ds xxx方式编译一下相关 ds 文件等，然后手动杀掉相关 pod，让 kubernetes 自动重建即可，如果命令行用着不爽也可以通过 dashboard 更改 2、如果还没开始搭建，或者可以停掉重建，那么只需在kubeadm init之前export KUBE_COMPONENT_LOGLEVEL=&#39;--v=0&#39;即可 四、新节点加入 dns 要你命当 kubeadm 创建好集群以后，如果有需要增加新节点，那么在 kubeadm join 之后务必检查 kube-dns 组件，dns 在某些(weave 启动不完整或不正常)情况下，会由于新节点加入而挂掉，此时整个集群 dns 失效，所以最好 join 完观察一会 dns 状态，如果发现不正常马上杀掉 dns pod，让 kubernetes 自动重建；如果情况允许最好全部 join 完成后直接干掉 dns 让 kubernetes 重建一下 五、单点的 dns 浪起来让你怕（更新-19.4.5）kubeadm 创建的 dns 默认也是单点的，而 dns 至关重要，只要一挂瞬间整个集群全部 game over；不过暂时还是没有发现能在 init 时候创建多个 dns 的方法；不过在集群创建后可以通过kubectl edit deploy kube-dns的方式修改其副本数量，让其创建多个副本即可，目前新版本kubernetes所使用的dns已经不是单pod三container，而是启动两个pod的coredns，解决单点问题 六、coredns一直处于ContainerCreating状态 Node加入集群中后一直处于NotReady状态，查看kube-system的状态，发现coredns一直处于ContainerCreating状态，flannel启动正常 12345# kubectl get nodesNAME STATUS ROLES AGE VERSIONmaster1.rsq.com NotReady master 16h v1.13.0node01.rsq.com NotReady &lt;none&gt; 16h v1.13.0node02.rsq.com NotReady &lt;none&gt; 8m39s v1.13.0 查看kubelet服务状态，看最后几行的报错 1234567891011121314151617181920212223242526# systemctl status kubelet● kubelet.service - kubelet: The Kubernetes Node Agent Loaded: loaded (/etc/systemd/system/kubelet.service; enabled; vendor preset: disabled) Drop-In: /etc/systemd/system/kubelet.service.d └─10-kubeadm.conf Active: active (running) since Wed 2018-12-12 09:24:44 CST; 6min ago Docs: https://kubernetes.io/docs/ Main PID: 123631 (kubelet) Memory: 35.2M CGroup: /system.slice/kubelet.service └─123631 /usr/bin/kubelet --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf --config=/var/lib/kubelet/config.yaml --cgrou...Dec 12 09:30:57 master1.rsq.com kubelet[123631]: E1212 09:30:57.187292 123631 pod_workers.go:190] Error syncing pod cea84a11-fd24-11e8-a282-000c291e37c2 ("coredns-86c58d9df4-fzs9l_kube-...Dec 12 09:30:57 master1.rsq.com kubelet[123631]: E1212 09:30:57.187480 123631 pod_workers.go:190] Error syncing pod cea7ebef-fd24-11e8-a282-000c291e37c2 ("coredns-86c58d9df4-hrwvk_kube-...Dec 12 09:30:59 master1.rsq.com kubelet[123631]: E1212 09:30:59.187419 123631 pod_workers.go:190] Error syncing pod cea84a11-fd24-11e8-a282-000c291e37c2 ("coredns-86c58d9df4-fzs9l_kube-...Dec 12 09:30:59 master1.rsq.com kubelet[123631]: E1212 09:30:59.187607 123631 pod_workers.go:190] Error syncing pod cea7ebef-fd24-11e8-a282-000c291e37c2 ("coredns-86c58d9df4-hrwvk_kube-...Dec 12 09:31:00 master1.rsq.com kubelet[123631]: W1212 09:31:00.454147 123631 cni.go:203] Unable to update cni config: No networks found in /etc/cni/net.dDec 12 09:31:00 master1.rsq.com kubelet[123631]: E1212 09:31:00.454242 123631 kubelet.go:2192] Container runtime network not ready: NetworkReady=false reason:NetworkPluginNot...initializedDec 12 09:31:01 master1.rsq.com kubelet[123631]: E1212 09:31:01.188877 123631 pod_workers.go:190] Error syncing pod cea7ebef-fd24-11e8-a282-000c291e37c2 ("coredns-86c58d9df4-hrwvk_kube-...Dec 12 09:31:01 master1.rsq.com kubelet[123631]: E1212 09:31:01.189259 123631 pod_workers.go:190] Error syncing pod cea84a11-fd24-11e8-a282-000c291e37c2 ("coredns-86c58d9df4-fzs9l_kube-...Dec 12 09:31:03 master1.rsq.com kubelet[123631]: E1212 09:31:03.187200 123631 pod_workers.go:190] Error syncing pod cea84a11-fd24-11e8-a282-000c291e37c2 ("coredns-86c58d9df4-fzs9l_kube-...Dec 12 09:31:03 master1.rsq.com kubelet[123631]: E1212 09:31:03.187730 123631 pod_workers.go:190] Error syncing pod cea7ebef-fd24-11e8-a282-000c291e37c2 ("coredns-86c58d9df4-hrwvk_kube-...Hint: Some lines were ellipsized, use -l to show in full.# 附加PS# 报错10.244.0.1 网络已存在（更新） 产生问题原因： 一直报网络NotReady，我就感觉flannel组件出了问题， 最后网上搜了一些资料解决参考博客：coreDNS一直处于创建中解决解决办法：所有节点执行（我只在master节点先执行就解决问题了） 12# rm -rf /var/lib/cni/flannel/* &amp;&amp; rm -rf /var/lib/cni/networks/cbr0/* &amp;&amp; ip link delete cni0# rm -rf /var/lib/cni/networks/cni0/* 删除flannel组件，重新下载 12# docker rmi quay.io/coreos/flannel:v0.10.0-amd64# kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml 查看节点状态已经处于Ready状态 12345# kubectl get nodesNAME STATUS ROLES AGE VERSIONmaster1.rsq.com Ready master 16h v1.13.0node01.rsq.com Ready &lt;none&gt; 16h v1.13.0node02.rsq.com Ready &lt;none&gt; 39m v1.13.0 七、kubeadm join报错12345678910在部署服务过程中，初始化之后重启了master节点，然后node节点在join进群的时候报错，提示证书是否过期等问题，报错信息如下：# kubeadm join 10.0.0.100:6443 --token qxl5b3.5b78nwu3gm1r4u6o --discovery-token-ca-cert-hash sha256:3e20fa8054cbc9000cf3d3586a05a01d8af5721b577856e93c7e243877393d21 --ignore-preflight-errors=Swap[preflight] Running pre-flight checks[WARNING Swap]: running with swap on is not supported. Please disable swap [WARNING SystemVerification]: this Docker version is not on the list of validated versions: 18.09.0. Latest validated version: 18.06[discovery] Trying to connect to API Server "10.0.0.100:6443"[discovery] Created cluster-info discovery client, requesting info from "https://10.0.0.100:6443"[discovery] Failed to request cluster info, will try again: [Get https://10.0.0.100:6443/api/v1/namespaces/kube-public/configmaps/cluster-info: dial tcp 10.0.0.100:6443: connect: connection refused][discovery] Failed to request cluster info, will try again: [Get https://10.0.0.100:6443/api/v1/namespaces/kube-public/configmaps/cluster-info: dial tcp 10.0.0.100:6443: connect: connection refused] 产生原因：有可能是时间不同步造成的，在初始化后重启master，重启后会报错 找了好多资料，没有找到可行的，最后kubeadm reset完美解决参考博文： k8s踩坑记 - kubeadm join 之 token 失效reset之后重新初始化 12# kubeadm reset # kubeadm init --kubernetes-version=v1.13.0 --pod-network-cidr=10.244.0.0/16 --service-cidr=10.96.0.0/12 --token-ttl=0 --ignore-preflight-errors=Swap 创建所需文件 123# mkdir -p $HOME/.kube# cp -i /etc/kubernetes/admin.conf $HOME/.kube/config# chown $(id -u):$(id -g) $HOME/.kube/config 查看节点 123# kubectl get nodesNAME STATUS ROLES AGE VERSIONmaster1.rsq.com NotReady master 2m49s v1.13.0 八、Etcd二进制安装目录也会报错哦etcd服务启动后报错etcd cluster ID mismatch：检查service配置cluster选项有无问题，若无问题，则可能是此前的etcd bootstrap加速启动缓存残留导致，坑爹的是rm -rf /var/lib/etcd/*删除完了之后还是报错，必须rm -rf /var/lib/etcd/才能彻底清除，删除完成后记得再创建该路径mkdir /var/lib/etcd，否则会有类似报错： 1etcd.service: Failed at step CHDIR spawning /usr/local/bin/etcd: No such file or directory 九、二进制安装后重建相关组件会出现secrets报错123May 27 10:34:45 kube-node3 journal: E0527 02:34:45.767392 1 config.go:322] Expected to load root CA config from /var/run/secrets/kubernetes.io/serviceaccount/ca.crt, but got err: open /var/run/secrets/kubernetes.io/serviceaccount/ca.crt: no such file or directory May 27 10:34:45 kube-node3 journal: E0527 02:34:45.767392 1 config.go:322] Expected to load root CA config from /var/run/secrets/kubernetes.io/serviceaccount/ca.crt, but got err: open /var/run/secrets/kubernetes.io/serviceaccount/ca.crt: no such file or directory 分析：产生这个错误是因为Kubernetes默认创建的secrets资源不包含用于访问kube-apiserver的根证书 需要给apiserver设置安全证书，然后删除默认secrets，系统会自动产生新的secrets secrets一般集群安装时默认自动创建 1# kubectl delete secret secretname -n Xxx 十、kubeadm生成集群，加入节点时发现忘记了join token 怎么办？ 1.生成一条永久有效的token 12345678&gt; # kubeadm token create --ttl 0 &gt; o4avtg.65ji6b778nyacw68 &gt; &gt; # kubeadm token list &gt; TOKEN TTL EXPIRES USAGES DESCRIPTION EXTRA GROUPS &gt; dxnj79.rnj561a137ri76ym &lt;invalid&gt; 2018-11-\#02T14:06:43+08:00 authentication,signing &lt;none&gt; system:bootstrappers:kubeadm:default-node-token &gt; o4avtg.65ji6b778nyacw68 &lt;forever&gt; &lt;never&gt; authentication,signing &lt;none&gt; system:bootstrappers:kubeadm:default-node-token &gt; 2.获取ca证书sha256编码hash值 1234&gt; # openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed 's/^.* //' &gt; &gt; 2cc3029123db737f234186636330e87b5510c173c669f513a9c0e0da395515b0 &gt; 3.node节点加入 12&gt; # kubeadm join x.x.x.x:6443 --token o4avtg.65ji6b778nyacw68 --discovery-token-ca-cert-hash sha256:2cc3029123db737f234186636330e87b5510c173c669f513a9c0e0da395515b0 &gt;]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>kubernetes_problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes安装-kubeadm_1.13.5]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2FKubernetes%E5%AE%89%E8%A3%85-kubeadm-1-13-5%2F</url>
    <content type="text"><![CDATA[环境描述 kubernetes version：1.13.5 docker version：18.6.3 Redhat：7.6 x.x.x.1 master-1 kube-apiserver、kube-controller-manager、kube-scheduler、etcd、keepalive、docker x.x.x.2 master-2 kube-apiserver、kube-controller-manager、kube-scheduler、etcd、keepalive、docker x.x.x.3 master-3 kube-apiserver、kube-controller-manager、kube-scheduler、etcd、keepalive、docker x.x.x.4 vip x.x.x.5 node-1 kubelet、docker x.x.x.6 node-2 kubelet、docker 因为担心kubeadm起来的etcd不稳定，这里用到的etcd对于kubernetes来说作为外部etcd集群。即使用二进制安装etcd集群，其余组件用kubeadm来完成安装。 环境准备1、准备工作12345678910111213141516echo "1" &gt; /proc/sys/net/bridge/bridge-nf-call-iptables# 停防火墙systemctl stop firewalldsystemctl disable firewalldsystemctl disable firewalld# 关闭Swapswapoff -ased 's/.*swap.*/#&amp;/' /etc/fstab# 关闭防火墙systemctl disable firewalld &amp;&amp; systemctl stop firewalld &amp;&amp; systemctl status firewalld# 关闭Selinuxsetenforce 0sed -i "s/^SELINUX=enforcing/SELINUX=disabled/g" /etc/sysconfig/selinuxsed -i "s/^SELINUX=enforcing/SELINUX=disabled/g" /etc/selinux/configsed -i "s/^SELINUX=permissive/SELINUX=disabled/g" /etc/sysconfig/selinuxsed -i "s/^SELINUX=permissive/SELINUX=disabled/g" /etc/selinux/config 2、docker安装1、下载设置源123sudo yum install -y yum-utils \ device-mapper-persistent-data \ lvm2 123yum-config-manager \--add-repo \https://download.daocloud.io/docker/linux/centos/docker-ce.repo 2、安装docker123yum list docker-ce --showduplicates | sort -r # 列出docker-ce的版本listyum install docker-ce-&lt;版本号&gt; -y # -y 安装docker需要的依赖，其中有个container-selinux的也可以单独下载# rpm -ivh container-selinux-2.33-1.git86f33cd.el7.noarch.rpm 3、启动docker12systemctl start dockerdocker version # 验证docker安装是否完成并启动成功 3、kubeadm/kubelet/kubectl安装 各节点安装 1234567891011121314cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOFyum install -y kubelet-1.13.5 kubeadm-1.13.5 kubectl-1.13.5 --disableexcludes=kubernetes #禁用除kubernetes之外的仓库,要用 -y 参数，会自动安装kube-cni等插件systemctl start kubeletsystemctl enable kubelet # kubeadm 要求kubelet保持开机自启状态 4、keepalive安装 master节点安装： 123456789101112131415161718192021222324252627282930313233343536373839404142yum install -y keepalivedsystemctl start keepalivedvim /etc/keepalived/keepalived.confglobal_defs &#123; router_id LVS_k8s&#125;vrrp_script CheckK8sMaster &#123; script &quot;curl -k https://10.70.49.130:6443&quot; interval 3 timeout 9 fall 2 rise 2&#125;vrrp_instance VI_1 &#123; state MASTER interface ens256 # 网卡 virtual_router_id 61 # 主节点权重最高 依次减少 priority 120 advert_int 1 #修改为本地IP mcast_src_ip x.x.x.2 nopreempt authentication &#123; auth_type PASS auth_pass sqP05dQgMSlzrxHj &#125; unicast_peer &#123; x.x.x.1 #x.x.x.2 x.x.x.3 &#125; virtual_ipaddress &#123; x.x.x.4 &#125; track_script &#123; CheckK8sMaster &#125;&#125; kubernetes部署1、etcd二进制部署1234567891011# 1.cfssl签发证书wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64chmod +x cfssl_linux-amd64mv cfssl_linux-amd64 /usr/local/bin/cfsslwget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64chmod +x cfssljson_linux-amd64mv cfssljson_linux-amd64 /usr/local/bin/cfssljsonwget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64chmod +x cfssl-certinfo_linux-amd64mv cfssl-certinfo_linux-amd64 /usr/local/bin/cfssl-certinfoexport PATH=/usr/local/bin:$PATH 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 2.根据config.json文件的格式创建如下的ca-config.json文件,过期时间设置成了 87600hmkdir /root/sslcd /root/sslcfssl print-defaults config &gt; config.jsoncfssl print-defaults csr &gt; csr.jsoncat &gt; ca-config.json &lt;&lt;EOF&#123; "signing": &#123; "default": &#123; "expiry": "87600h" &#125;, "profiles": &#123; "kubernetes": &#123; "usages": [ "signing", "key encipherment", "server auth", "client auth" ], "expiry": "87600h" &#125; &#125; &#125;&#125;EOFcat &gt; ca-csr.json &lt;&lt;EOF&#123; "CN": "kubernetes", "key": &#123; "algo": "rsa", "size": 2048 &#125;, "names": [ &#123; "C": "CN", "ST": "BeiJing", "L": "BeiJing", "O": "k8s", "OU": "System" &#125; ]&#125;EOFcfssl gencert -initca ca-csr.json | cfssljson -bare ca 12345678910111213141516171819202122232425262728293031323334# 3.创建kubernetes-etcd证书cat &gt; kubernetes-etcd-csr.json &lt;&lt;EOF&#123; "CN": "kubernetes", "hosts": [ "x.x.x.1", "x.x.x.2", "x.x.x.3", "x.x.x.4", "127.0.0.1", "10.254.0.1", "kubernetes", "kubernetes.default", "kubernetes.default.svc", "kubernetes.default.svc.cluster", "kubernetes.default.svc.cluster.local" ], "key": &#123; "algo": "rsa", "size": 2048 &#125;, "names": [ &#123; "C": "CN", "ST": "BeiJing", "L": "BeiJing", "O": "k8s", "OU": "System" &#125; ]&#125;EOFcfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kubernetes-etcd-csr.json | cfssljson -bare etcd 123456# 4.目录证书文件如下etcd-key.pem etcd.pem ca.pem ca.key# 保证三节点证书一致scp /etc/etcd/ssl/* master2:/etc/etcd/ssl/scp /etc/etcd/ssl/* master3:/etc/etcd/ssl/ 证书生成完毕之后，将CA证书ca.pem, etcd秘钥etcd-key.pem, etcd证书etcd.pem拷贝到各节点的/etc/etcd/ssl目录中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# 这里就用etcd 3.3.10版本# 一：wget https://github.com/coreos/etcd/releases/download/v3.3.10/etcd-v3.3.10-linux-amd64.tar.gz# 解压缩etcd-v3.3.10-linux-amd64.tar.gz，将其中的etcd和etcdctl两个可执行文件复制到各节点的/usr/bin和/usr/local/bin目录。tar zxvf etcd-v3.3.10-linux-amd64.tar.gzcp etcd-v3.3.10-linux-amd64/etcd* /usr/local/bin/cp etcd-v3.3.10-linux-amd64/etcd* /usr/bin/mkdir /var/lib/etcd #etcd的数据目录mkdir /etc/etcd #etcd的配置文件目录# 二：yum -y install etcd# 安装好etcd之后，就可以修改etcd配置以及启动service，文件路径为：/etc/etcd/etcd.conf和/usr/lib/systemd/system/etcd.servicecat &gt; /etc/etcd/etcd.conf &lt;&lt; EOF# [member]ETCD_NAME=etcd1 # etcd名字 三节点的话为 etcd1 etcd2 etcd3ETCD_DATA_DIR="/data/etcd" # etcd数据目录指定ETCD_LISTEN_PEER_URLS="https://x.x.x.1:2380" # 修改每个master节点的ipETCD_LISTEN_CLIENT_URLS="https://x.x.x.1:2379"#[cluster]ETCD_INITIAL_ADVERTISE_PEER_URLS="https://x.x.x.1:2380"ETCD_INITIAL_CLUSTER_TOKEN="etcd-cluster"ETCD_ADVERTISE_CLIENT_URLS="https://x.x.x.1:2379"EOFcat &gt; /usr/lib/systemd/system/etcd.service &lt;&lt; EOF[Unit]Description=Etcd ServerAfter=network.targetAfter=network-online.targetWants=network-online.targetDocumentation=https://github.com/coreos[Service]Type=notifyWorkingDirectory=/var/lib/etcd/EnvironmentFile=-/etc/etcd/etcd.confExecStart=/usr/local/bin/etcd \ --name $&#123;ETCD_NAME&#125; \ --cert-file=/etc/etcd/ssl/etcd.pem \ --key-file=/etc/etcd/ssl/etcd-key.pem \ --peer-cert-file=/etc/etcd/ssl/etcd.pem \ --peer-key-file=/etc/etcd/ssl/etcd-key.pem \ --trusted-ca-file=/etc/etcd/ssl/ca.pem \ --peer-trusted-ca-file=/etc/etcd/ssl/ca.pem \ --initial-advertise-peer-urls $&#123;ETCD_INITIAL_ADVERTISE_PEER_URLS&#125; \ --listen-peer-urls $&#123;ETCD_LISTEN_PEER_URLS&#125; \ --listen-client-urls $&#123;ETCD_LISTEN_CLIENT_URLS&#125;,http://127.0.0.1:2379 \ --advertise-client-urls $&#123;ETCD_ADVERTISE_CLIENT_URLS&#125; \ --initial-cluster-token $&#123;ETCD_INITIAL_CLUSTER_TOKEN&#125; \ --initial-cluster etcd1=https://x.x.x.1:2380,etcd2=https://x.x.x.2:2380,etcd3=https://x.x.x.3:2380 \ --initial-cluster-state new \ --data-dir=$&#123;ETCD_DATA_DIR&#125;Restart=on-failureRestartSec=5LimitNOFILE=65536[Install]WantedBy=multi-user.targetEOF# 上面在启动参数中指定了etcd的工作目录和数据目录分别是/var/lib/etcd和/data/etcd# –cert-file和–key-file分别指定etcd的公钥证书和私钥# –peer-cert-file和–peer-key-file分别指定了etcd的Peers通信的公钥证书和私钥。# –trusted-ca-file指定了客户端的CA证书# –peer-trusted-ca-file指定了Peers的CA证书# –initial-cluster-state new表示这是新初始化集群，–name指定的参数值必须在–initial-cluster中# 高可用etcd启动需要多节点同时启动才能起来服务# 分别在master节点同时启动etcdsystemctl start etcd.servicesystemctl enable etcd.service 至此，etcd高可用集群搭建完成，可用一下命令验证etcd集群 123456etcdctl \ --ca-file=/etc/etcd/ssl/ca.pem \ --cert-file=/etc/etcd/ssl/etcd.pem \ --key-file=/etc/etcd/ssl/etcd-key.pem \ --endpoints=https://x.x.x.1:2379,https://x.x.x.2:2379,https://x.x.x.3:2379 \ cluster-health 2、kubeadm部署1、master部署 部署之前请确保下载好相关image，翻墙下载或者国内dockerhub下载kubernetes镜像 1、初始化master1 创建master1的初始化配置文件,网络插件采用flannel，CIDR地址是 “10.244.0.0/16”，如下为1.13.5新版本配置文件。 123456789101112131415161718192021222324252627282930313233cat &gt; kubeadm-master.yaml &lt;&lt; EOFapiVersion: kubeadm.k8s.io/v1beta1kind: InitConfigurationlocalAPIEndpoint: advertiseAddress: x.x.x.1 # 本机ip，这里为x.x.x.1-3 bindPort: 6443---apiVersion: kubeadm.k8s.io/v1beta1kind: ClusterConfigurationkubernetesVersion: v1.13.5 # kubernetes版本 对应下载的imageimageRepository: k8s.gcr.io # 自己修改为自己的镜像库名apiServer: certSANs: - "master1" - "master2" - "master3" - "x.x.x.1" - "x.x.x.2" - "x.x.x.3" - "x.x.x.4" - "127.0.0.1"controlPlaneEndpoint: "x.x.x.4:8443" # 控制台ip指定，即vip 实现apiserver高可用etcd: external: endpoints: - https://x.x.x.1:2379 - https://x.x.x.2:2379 - https://x.x.x.3:2379networking: podSubnet: "10.244.0.0/16"EOF 123# 运行初始化命令即可，前提要把相关设置关闭，详情至准备工作# 其中在kubelet配置里加入--pod-infra-container-image 参数指定 pause私有镜像库镜像kubeadm init --config kubeadm-master.yaml 在初始化配置里，对于etcd有两种高可用的选项，一个使用内部etcd，一个使用外部etcd(独立搭建的etcd集群，而不是在初始化中搭建的)，两者初始化配置文件略有不同。 1234567891011121314151617# 使用内部etcd的话，初始化yaml文件中etcd配置如下：etcd: local: extraArgs: listen-client-urls: "https://127.0.0.1:2379,https://x.x.x.x:2379" advertise-client-urls: "https://x.x.x.x:2379" listen-peer-urls: "https://x.x.x.x:2380" initial-advertise-peer-urls: "https://x.x.x.x:2380" initial-cluster: "master1.hanli.com=https://x.x.x.x:2380"# 使用外部etcd的话，etcd: #ETCD的地址 external: endpoints: - https://x.x.x.1:2379 - https://x.x.x.2:2379 - https://x.x.x.3:2379 init初始化之后，如果成功会出现join，这时就可以运行一下命令 机器上的用户要使用kubectl来管理集群操作集群 123mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config 验证命令 1234567891011kubectl get cs # 如下信息NAME STATUS MESSAGE ERRORcontroller-manager Healthy okscheduler Healthy oketcd-1 Healthy &#123;"health": "true"&#125;etcd-0 Healthy &#123;"health": "true"&#125;etcd-2 Healthy &#123;"health": "true"&#125;kubectl get node # notReady 状态，是因为没有安装网络插件 Name成ip，可修改kubelet的启动参数即可NAME STATUS ROLES AGE VERSIONmaster1 NotReady master 1m v1.13.5 2、启动flannel服务123456789101112wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml# flannel 默认会使用主机的第一张网卡，如果你有多张网卡，需要通过配置单独指定。修改 kube-flannel.yml 中的以下部分cat kube-flannel.yml containers: - name: kube-flannel image: quay.io/coreos/flannel:v0.11.0-amd64 # 修改下自己私有镜像库的flannel镜像名 command: - /opt/bin/flanneld args: - --ip-masq - --kube-subnet-mgr - --iface=ens33 #添加 1234567891011121314kubectl apply -f kube-flannel.yml # 创建pod，因为是ds的所以后续集群里面加节点就会自动启动flannelkubectl get node # 会发现 node状态变成了 ReadyNAME STATUS ROLES AGE VERSIONmaster1 Ready master 10m v1.13.5kubectl get po --all-namespacesNAMESPACE NAME READY STATUS RESTARTS AGEkube-system coredns-86c58d9df4-r59rv 1/1 Running 0 59mkube-system coredns-86c58d9df4-rbzx5 1/1 Running 0 59mkube-system kube-apiserver-master1 1/1 Running 0 58mkube-system kube-controller-manager-master1 1/1 Running 16 58mkube-system kube-flannel-ds-amd64-229j2 1/1 Running 0 42mkube-system kube-proxy-4wrg5 1/1 Running 0 59mkube-system kube-scheduler-master1 1/1 Running 13 58m 不是running状态，就说明出错了，通过查看 描述：kubectl describe pod kube-scheduler-master.hanli.com -n kube-system 日志：kubectl logs kube-scheduler-master.hanli.com -n kube-system flannel服务启动成功后，coredns也就会自动启动成功，状态为Running 3、初始化其他master节点 首先把master1上生成的ca证书等，拷贝到其他master节点上，最好免密，可使用pscp等批量任务 123456789101112131415161718192021&gt; #!/bin/bash&gt; #注意修改为自己的主机名&gt; export CONTROL_PLANE_IPS="master2 master3" &gt; &gt; # 保证节点有/etc/kubernetes/pki目录&gt; # 把以下证书复制到其他master节点&gt; for host in $&#123;CONTROL_PLANE_IPS&#125;; do&gt; # ！！！修正拷贝证书的时候请指定特定证书拷贝（之前的已经备注，新加的有etcd目录，没有用外部etcd集群），因为在证书拷贝的情况下吃过亏，因此修改此处！！！&gt; # 附issue：https://github.com/kubernetes/kubeadm/issues/1321 &gt; # 找了好久终于！！！哭&gt; #scp /etc/kubernetes/pki/*.crt $host:/etc/kubernetes/pki/&gt; #scp /etc/kubernetes/pki/*.key $host:/etc/kubernetes/pki/&gt; #scp /etc/kubernetes/pki/*.pub $host:/etc/kubernetes/pki/&gt; #scp /etc/kubernetes/admin.conf $host:/etc/kubernetes/admin.conf&gt; scp /etc/kubernetes/pki/ca.* "$&#123;USER&#125;"@$host:/etc/kubernetes/pki/&gt; scp /etc/kubernetes/pki/sa.* "$&#123;USER&#125;"@$host:/etc/kubernetes/pki/&gt; scp /etc/kubernetes/pki/front-proxy-ca.* "$&#123;USER&#125;"@$host:/etc/kubernetes/pki/&gt; scp /etc/kubernetes/pki/etcd/ca.* "$&#123;USER&#125;"@$host:/etc/kubernetes/pki/etcd/&gt; scp /etc/kubernetes/admin.conf "$&#123;USER&#125;"@$host:/etc/kubernetes/&gt; done&gt; 1234567891011121314151617&gt; tree /etc/kubernetes/pki/&gt; /etc/kubernetes/pki/&gt; ├── apiserver.crt&gt; ├── apiserver-etcd-client.crt&gt; ├── apiserver-etcd-client.key&gt; ├── apiserver.key&gt; ├── apiserver-kubelet-client.crt&gt; ├── apiserver-kubelet-client.key&gt; ├── ca.crt&gt; ├── ca.key&gt; ├── front-proxy-ca.crt&gt; ├── front-proxy-ca.key&gt; ├── front-proxy-client.crt&gt; ├── front-proxy-client.key&gt; ├── sa.key&gt; └── sa.pub&gt; In v1.8.0, kubeadm introduced the kubeadm alpha phase command with the aim of making kubeadm more modular. In v1.13.0 this command graduated to kubeadm init phase. This modularity enables you to invoke atomic sub-steps of the bootstrap process. Hence, you can let kubeadm do some parts and fill in yourself where you need customizations. kubeadm init phase is consistent with the kubeadm init workflow, and behind the scene both use the same code. 在v1.8.0中，kubeadm引入了该kubeadm alpha phase命令，目的是使kubeadm更加模块化。在v1.13.0中，此命令逐渐变为kubeadm init phase。此模块化使您可以调用引导过程的原子子步骤。因此，您可以让kubeadm执行某些操作，并在需要自定义的位置填写您自己的位置。 kubeadm init phase与kubeadm init工作流程一致，并且在场景后面都使用相同的代码。 123kubectl init --config kube-master.yaml# 分别修改对应ip，在在master2-3并执行即可 步骤如master1# 等待kube-proxy flannel启动成功即可 1234567891011121314151617181920kubectl get po -n kube-systemNAME READY STATUS RESTARTS AGEcoredns-9f9d9c76-4zrt4 1/1 Running 0 2dcoredns-9f9d9c76-dqd4c 1/1 Running 0 2dkube-apiserver-zjjh-rq-k8s-1 1/1 Running 0 2dkube-apiserver-zjjh-rq-k8s-2 1/1 Running 0 2dkube-apiserver-zjjh-rq-k8s-3 1/1 Running 0 2dkube-controller-manager-zjjh-rq-k8s-1 1/1 Running 0 2dkube-controller-manager-zjjh-rq-k8s-2 1/1 Running 0 2dkube-controller-manager-zjjh-rq-k8s-3 1/1 Running 0 2dkube-flannel-ds-amd64-7ghn7 1/1 Running 1 2dkube-flannel-ds-amd64-9cqts 1/1 Running 0 2dkube-flannel-ds-amd64-f57nh 1/1 Running 1 2dkube-proxy-8fwts 1/1 Running 0 2dkube-proxy-95tjb 1/1 Running 0 2dkube-proxy-bls94 1/1 Running 0 2dkube-scheduler-zjjh-rq-k8s-1 1/1 Running 0 2dkube-scheduler-zjjh-rq-k8s-2 1/1 Running 0 2dkube-scheduler-zjjh-rq-k8s-3 1/1 Running 0 2dkubernetes-dashboard-67d49f7868-x79wf 1/1 Running 0 76m 2、Work节点加入集群 输入master节点初始化成功之后出现的join命令，出现kubectl get nodes即成功 12&gt; kubeadm join x.x.x.4:8443 --token bnnsb7.amapp1t78llxn54d --discovery-token-ca-cert-hash sha256:520ef89be84c30e480db6d441a7e4179634a9455f0009e249ebe8f35fa792087&gt; 3、集群验证1234567891011121314151617181920# 节点状态[root@master] ~$ kubectl get nodes# 组件状态[root@master] ~$ kubectl get cs# 服务账户[root@master] ~$ kubectl get serviceaccount# 集群信息[root@master] ~$ kubectl cluster-info# 验证dns功能[root@master] ~$ kubectl run curl --image=radial/busyboxplus:curl -it[ root@curl-66959f6557-r4crd:/ ]$ nslookup kubernetes.defaultServer: 10.96.0.10Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.localName: kubernetes.defaultAddress 1: 10.96.0.1 kubernetes.default.svc.cluster.local 附录： 12&gt;# kubelet.service配置文件 /use/lib/systemd/system/kubelet.service.d/10-kubeadm.conf&gt; 参考链接： kubeadm安装1.13.5：https://blog.csdn.net/fanren224/article/details/86573264#2master1_165 二进制安装：https://github.com/mritd/ktool 二进制安装kubernetes_v1.13.4：https://mritd.me/2019/03/16/set-up-kubernetes-1.13.4-cluster/]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>Kubernetes_ha</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一点Haproxy参数的文档]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2F%E8%AE%B0%E4%B8%80%E7%82%B9Haproxy%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[Haproxy的一些配置参数，/etc/haproxy/haproxy.cfg 主要是配置项的超时参数，如下： 1234567891011121314151617181920&gt; # 反映连接haproxy集群报错，查看应用服务器进程大量的端口连接处于colse_wait状态。&gt; # 这个haproxy的redis集群类似配置已经好几组了，配置都相同问啥别的都好好的这个却有问题。&gt; # 自己尝试使用redis-cli连接（haproxy做的redis分片集群），确实能够正常连接操作，但是连接状态马上就会变成close_wait状态，重新执行命令这个close_wait状态会恢复ESTABLISHED，但是细心看端口号已经变化，也就是redis-cli发生了重新连接。于是问题清晰了：用户客户端工具建立链接后，没有自动重连来保持连接，导致超时，服务器主动断开连接，客户端再次链接的时候socket已经损坏不可用了，导致报错&gt; # 解决办法：调整haproxy的超时参数：&gt; timeout connect 5s&gt; timeout queue 5s&gt; timeout client 30s&gt; timeout server 30s&gt; timeout client-fin 30s&gt; timeout server-fin 30s&gt; timeout tunnel 1h&gt; # 参数解释：&gt; timeout connect 连接尝试成功连接到server的超时时间&gt; timeout queue 在队列等待连接槽释放的超时时间&gt; timeout server server端非活动状态超时时间&gt; timeout client 客户端非活动状态超时时间&gt; timeout server-fin 半关闭状态连接，server端非活动超时时间&gt; timeout client-fin 半关闭状态连接，client端非活动超时时间&gt; timeout tunnel 客户端和服务器端通道非活动超时时间&gt;]]></content>
      <tags>
        <tag>Haproxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_list去重]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2FPython-list%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[Python_list去重集中记录一下方法怎么快速的对列表进行去重呢，去重之后原来的顺序会不会改变呢？1.以下的几种情况结果是一样的，去重之后顺序会改变:1234567# 最常用ids = [1,2,3,3,4,2,3,4,5,6,1]news_ids = []for id in ids: if id not in news_ids: news_ids.append(id)print news_ids 或用set123# 使用set如果列表里面有字典活着其他数据结构，貌似不会去重。ids = [1,4,3,3,4,2,3,4,5,6,1]ids = list(set(ids)) 或使用itertools.grouby123456import itertoolsids = [1,4,3,3,4,2,3,4,5,6,1]ids.sort()it = itertools.groupby(ids)for k, g in it: print k 关于itertools.groupby的原理可以看这里： (1) http://docs.python.org/2/library/itertools.html#itertools.groupby (2)https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001415616001996f6b32d80b6454caca3d33c965a07611f000 2.怎么能不改变原来的顺序呢？(要用到reduce 关于reduce的介绍 http://docs.python.org/2/library/functions.html#reduce) 关于lambda的文章:http://www.cnblogs.com/nyist-xsk/p/7404675.html 关于reduce的文章: (1) http://www.cnblogs.com/XXCXY/p/5180245.html (2) http://www.pythoner.com/46.html 1234In [5]: ids = [1,4,3,3,4,2,3,4,5,6,1]In [6]: func = lambda x,y:x if y in x else x + [y]In [7]: reduce(func, [[], ] + ids)Out[7]: [1, 4, 3, 2, 5, 6] 其中的 lambda x,y:x if y in x else x + [y] 等价于 lambda x,y: y in x and x or x+[y] 。思路其实就是先把ids变为[[], 1,4,3,……] ,然后在利用reduce的特性. 去列表去重，不改变原来的顺序，还可以使用一个空列表把原列表里面不重复的数据”装起来”，例如：123456789101112131415161718list2 = []list1 = [1,2,3,2,2,2,4,6,5]for i in list1: if i not in list2: list2.append(i)list2[1, 2, 3, 4, 6, 5]或者使用删除元素索引的方法对列表去重，并且不改变原列表的顺序# python for删除的时候会往前移(垃圾回收机制)，未遍历到的后一个占了前一个被删除的"位置"，导致这个数不会被遍历到，而使最后的结果错误# 局部变量在栈内存中存在,当for循环语句结束,那么变量会及时被gc(垃圾回收器)及时的释放掉,不浪费空间；# 如果使用循环之后还想去访问循环语句中控制那个变量,使用while循环。# 所以使用while循环删除nums中的Val(的下标)nums = [1,2,3,3,4,2,3,4,5,6,1]val = 3while val in nums: nums.pop(nums.index(val))print numsreturn len(nums)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python_碎片化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang_问题]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2FGolang-%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[（持续更新） 一、gorm遇到invalid connection报错 (/data/dcops_workspace/src/x.x.x.x/xxxx/model/containerappid_info.go:76)[2019-04-09 14:41:40] invalid connection 现象：今天使用gorm时，总遇到invalid connection报错，导致过一段时间调一下接口服务容器就会重启 网上查了文档看了gorm的mysql连接池的参数： dcosdb.DB().SetMaxIdleConns(10) // SetMaxIdleConns设置idle connection pool的最大连接数。如果MaxOpenConns的值 &gt; 0，但是小于这里设置的MaxIdleConns，则MaxIdleConns将自动降到与MaxOpenConns的限制相同。如果 &lt;= 0, 则没有空闲连接会被保留。最大空闲连接数 dcosdb.DB().SetMaxOpenConns(100) //SetMaxOpenConns用于设置Database最大可以打开的连接数。如果 &lt;= 0, 则没有连接限制。且默认值为0（无限制）。数据库最大连接数 dcosdb.DB().SetConnMaxLifetime(time.Second 5) // SetConnMaxLifetime用于设置连接可被重新使用的最大时间间隔。如果超时，则连接会在重新使用前被关闭。如果 d &lt;= 0, 则连接将被永久保留。**连接最长存活期，超过这个时间连接将不再被复用*** 原因是：程序在重复使用数据库tcp连接池中的某个连接时，该命中连接可能已被服务器过期丢弃，而客户端这边认为该连接为过期，还有效。此时会报错 invalid connection。随后将该连接重连接池中丢弃 原因参考：https://blog.csdn.net/dghpgyss/article/details/86480837 1234// 发现我把dcosdb.DB().SetConnMaxLifetime(time.Second * 5)这个参数设置成了dcosdb.DB().SetConnMaxLifetime(time.Hour)导致了每次连接丢弃，但是客户端不知道。服务端主动关闭了连接，因为服务端对连接的保持超时时间到了也关闭的，所以可以设置客户端连接超时时间小于服务端DB.SetConnMaxLifetime(time.Second)// SetConnMaxLifetime sets the maximum amount of time a connection may be reused.dcosdb.DB().SetConnMaxLifetime(time.Second * 5)// dcosdb.DB().SetConnMaxLifetime(time.Hour) 设置成了1小时 二、]]></content>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang并发之原子操作]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2FGolang%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[转自：http://ifeve.com/go-concurrency-atomic/ 原理多，代码量偏少。 我们已经知道，原子操作即是进行过程中不能被中断的操作。也就是说，针对某个值的原子操作在被进行的过程当中，CPU绝不会再去进行其它的针对该值的操作。无论这些其它的操作是否为原子操作都会是这样。为了实现这样的严谨性，原子操作仅会由一个独立的CPU指令代表和完成。只有这样才能够在并发环境下保证原子操作的绝对安全。Go语言提供的原子操作都是非侵入式的。它们由标准库代码包sync/atomic中的众多函数代表。我们可以通过调用这些函数对几种简单的类型的值进行原子操作。这些类型包括int32、int64、uint32、uint64、uintptr和unsafe.Pointer类型，共6个。这些函数提供的原子操作共有5种，即：增或减、比较并交换、载入、存储和交换。它们分别提供了不同的功能，且适用的场景也有所区别。下面，我们就根据这些种类对Go语言提供的原子操作进行逐一的讲解。 \1. 增或减被用于进行增或减的原子操作（以下简称原子增/减操作）的函数名称都以“Add”为前缀，并后跟针对的具体类型的名称。例如，实现针对uint32类型的原子增/减操作的函数的名称为AddUint32。事实上，sync/atomic包中的所有函数的命名都遵循此规则。顾名思义，原子增/减操作即可实现对被操作值的增大或减小。因此，被操作值的类型只能是数值类型。更具体的讲，它只能是我们在前面提到的int32、int64、uint32、uint64和uintptr类型。例如，我们如果想原子的把一个int32类型的变量i32的值增大3的话，可以这样做： 1newi32 := atomic.AddInt32(&amp;i32, 3) 我们将指向i32变量的值的指针值和代表增减的差值3作为参数传递给了atomic.AddInt32函数。之所以要求第一个参数值必须是一个指针类型的值，是因为该函数需要获得到被操作值在内存中的存放位置，以便施加特殊的CPU指令。从另一个角度看，对于一个不能被取址的数值，我们是无法进行原子操作的。此外，这类函数的第二个参数的类型被操作值的类型总是相同的。因此，在前面那个调用表达式被求值的时候，字面量3会被自动转换为一个int32类型的值。函数atomic.AddInt32在被执行结束之时会返回经过原子操作后的新值。不过不要误会，我们无需把这个新值再赋给原先的变量i32。因为它的值已经在atomic.AddInt32函数返回之前被原子的修改了。与该函数类似的还有atomic.AddInt64函数、atomic.AddUint32函数、atomic.AddUint64函数和atomic.AddUintptr函数。这些函数也可以被用来原子的增/减对应类型的值。例如，如果我们要原子的将int64类型的变量i64的值减小3话，可以这样编写代码： 12var i64 int64atomic.AddInt64(&amp;i64, -3) 不过，由于atomic.AddUint32函数和atomic.AddUint64函数的第二个参数的类型分别是uint32和uint64，所以我们无法通过传递一个负的数值来减小被操作值。那么，这是不是就意味着我们无法原子的减小uint32或uint64类型的值了呢？幸好，不是这样。Go语言为我们提供了一个可以迂回的达到此目的办法。如果我们想原子的把uint32类型的变量ui32的值增加NN（NN代表了一个负整数），那么我们可以这样调用atomic.AddUint32函数： 1atomic.AddUint32(&amp;ui32, ^uint32(-NN-1)) 对于uint64类型的值来说也是这样。调用表达式 1atomic.AddUint64(&amp;ui64, ^uint64(-NN-1)) 表示原子的把uint64类型的变量ui64的值增加NN（或者说减小-NN）。之所以这种方式可以奏效，是因为它利用了二进制补码的特性。我们知道，一个负整数的补码可以通过对它按位（除了符号位之外）求反码并加一得到。我们还知道，一个负整数可以由对它的绝对值减一并求补码后得到的数值的二进制表示来代表。例如，如果NN是一个int类型的变量且其值为-35，那么表达式 1uint32(int32(NN)) 和 1^uint32(-NN-1) 的结果值就都会是11111111111111111111111111011101。由此，我们使用^uint32(-NN-1)和^uint64(-NN-1)来分别表示uint32类型和uint64类型的NN就顺理成章了。这样，我们就可以合理的绕过uint32类型和uint64类型对值的限制了。以上是官方提供一种通用解决方案。除此之外，我们还有两个非通用的方案可供选择。首先，需要明确的是，对于一个代表负数的字面常量来说，它们是无法通过简单的类型转换将其转换为uint32类型或uint64类型的值的。例如，表达式uint32(-35)和uint64(-35)都是不合法的。它们都不能通过编译。但是，如果我们事先把这个字面量赋给一个变量然后再对这个变量进行类型转换，那么就可以得到Go语言编译器的认可。我们依然以值为-35的变量NN为例，下面这条语句可以通过编译并被正常执行： 1fmt.Printf("The variable: %b.\n", uint32(NN)) 其输出内容为： 1The variable: 11111111111111111111111111011101. 可以看到，表达式uint32(NN)的结果值的二进制表示与前面的uint32(int32(NN))表达式以及^uint32(-NN-1)表达式的结果值是一致的。它们都可以被用来表示uint32类型的-35。因此，我们也可以使用下面的调用表达式来原子的把变量ui32的值减小-NN：atomic.AddUint32(&amp;ui32, uint32(NN))不过，这样的编写方式仅在NN是数值类型的变量的时候才可以通过编译。如果NN是一个常量，那么也会使表达式uint32(NN)不合法并无法通过编译。它与表达式uint32(-35)造成的编译错误是一致的。在这种情况下，我们可以这样来达到上述目的： 1atomic.AddUint32(&amp;ui32, NN&amp;math.MaxUint32) 其中，我们用到了标准库代码包math中的常量MaxUint32。math.MaxUint32常量表示的是一个32位的、所有二进制位上均为1的数值。我们把NN和math.MaxUint32进行按位与操作的意义是使前者的值能够被视为一个uint32类型的数值。实际上，对于表达式NN&amp;math.MaxUint32来说，其结果值的二进制表示与前面uint32(int32(NN))表达式以及^uint32(-NN-1)表达式的结果值也是一致的。我们在这里介绍的这两种非官方的解决方案是不能混用的。更具体地说，如果NN是一个常量，那么表达式uint32(NN)是无法通过编译的。而如果NN是一个变量，那么表达式NN&amp;math.MaxUint32就无法通过编译。前者的错误在于代表负整数的字面常量不能被转换为uint32类型的值。后者的错误在于这个按位与运算的结果值的类型不是uint32类型而是int类型，从而导致数据溢出的错误。相比之下，官方给出的那个解决方案的适用范围更广。有些读者可能会有这样的疑问：为什么如此曲折的实现这一功能？直接声明出atomic.SubUint32()函数和atomic.SubUint64()函数不好吗？作者理解，不这样做是为了让这些原子操作的API可以整齐划一，并且避免在扩充它们的时候使sync/atomic包中声明的程序实体成倍增加。（作者向Go语言官方提出了这个问题并引发了一些讨论，他们也许会使用投票的方式来选取更好一些的方案）注意，并不存在名为atomic.AddPointer的函数，因为unsafe.Pointer类型值之间既不能被相加也不能被相减。\2. 比较并交换有些读者可能很熟悉比较并交换操作的英文称谓——Compare And Swap，简称CAS。在sync/atomic包中，这类原子操作由名称以“CompareAndSwap”为前缀的若干个函数代表。我们依然以针对int32类型值的函数为例。该函数名为CompareAndSwapInt32。其声明如下： 1func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) 可以看到，CompareAndSwapInt32函数接受三个参数。第一个参数的值应该是指向被操作值的指针值。该值的类型即为*int32。后两个参数的类型都是int32类型。它们的值应该分别代表被操作值的旧值和新值。CompareAndSwapInt32函数在被调用之后会先判断参数addr指向的被操作值与参数old的值是否相等。仅当此判断得到肯定的结果之后，该函数才会用参数new代表的新值替换掉原先的旧值。否则，后面的替换操作就会被忽略。这正是“比较并交换”这个短语的由来。CompareAndSwapInt32函数的结果swapped被用来表示是否进行了值的替换操作。与我们前面讲到的锁相比，CAS操作有明显的不同。它总是假设被操作值未曾被改变（即与旧值相等），并一旦确认这个假设的真实性就立即进行值替换。而使用锁则是更加谨慎的做法。我们总是先假设会有并发的操作要修改被操作值，并使用锁将相关操作放入临界区中加以保护。我们可以说，使用锁的做法趋于悲观，而CAS操作的做法则更加乐观。CAS操作的优势是，可以在不形成临界区和创建互斥量的情况下完成并发安全的值替换操作。这可以大大的减少同步对程序性能的损耗。当然，CAS操作也有劣势。在被操作值被频繁变更的情况下，CAS操作并不那么容易成功。有些时候，我们可能不得不利用for循环以进行多次尝试。示例如下： 123456789var value int32func addValue(delta int32) &#123; for &#123; v := value if atomic.CompareAndSwapInt32(&amp;value, v, (v + delta)) &#123; break &#125; &#125;&#125; 可以看到，为了保证CAS操作的成功完成，我们仅在CompareAndSwapInt32函数的结果值为true时才会退出循环。这种做法与自旋锁的自旋行为相似。addValue函数会不断的尝试原子的更新value的值，直到这一操作成功为止。操作失败的缘由总会是value的旧值已不与v的值相等了。如果value的值会被并发的修改的话，那么发生这种情况是很正常的。CAS操作虽然不会让某个Goroutine阻塞在某条语句上，但是仍可能会使流程的执行暂时停滞。不过，这种停滞的时间大都极其短暂。请记住，当想并发安全的更新一些类型（更具体的讲是，前文所述的那6个类型）的值的时候，我们总是应该优先选择CAS操作。与此对应，被用来进行原子的CAS操作的函数共有6个。除了我们已经讲过的CompareAndSwapInt32函数之外，还有CompareAndSwapInt64、CompareAndSwapPointer、CompareAndSwapUint32、CompareAndSwapUint64 和CompareAndSwapUintptr函数。这些函数的结果声明列表与CompareAndSwapInt32函数的完全一致。而它们的参数声明列表与后者也非常类似。虽然其中的那三个参数的类型不同，但其遵循的规则是一致的，即：第二个和第三个参数的类型均为与第一个参数的类型（即某个指针类型）紧密相关的那个类型。例如，如果第一个参数的类型为*unsafe.Pointer，那么后两个参数的类型就一定是unsafe.Pointer。这也是由这三个参数的含义决定的。\3. 载入在前面示例的for循环中，我们使用语句v := value为变量v赋值。但是，要注意，其中的读取value的值的操作并不是并发安全的。在该读取操作被进行的过程中，其它的对此值的读写操作是可以被同时进行的。它们并不会受到任何限制。在第7章的第1节的最后，我们举过这样一个例子：在32位计算架构的计算机上写入一个64位的整数。如果在这个写操作未完成的时候有一个读操作被并发的进行了，那么这个读操作很可能会读取到一个只被修改了一半的数据。这种结果是相当糟糕的。为了原子的读取某个值，sync/atomic代码包同样为我们提供了一系列的函数。这些函数的名称都以“Load”为前缀，意为载入。我们依然以针对int32类型值的那个函数为例。我们下面利用LoadInt32函数对上一个示例稍作修改： 12345678func addValue(delta int32) &#123; for &#123; v := atomic.LoadInt32(&amp;value) if atomic.CompareAndSwapInt32(&amp;value, v, (v + delta)) &#123; break &#125; &#125;&#125; 函数atomic.LoadInt32接受一个int32类型的指针值，并会返回该指针值指向的那个值。在该示例中，我们使用调用表达式atomic.LoadInt32(&amp;value)替换掉了标识符value。替换后，那条赋值语句的含义就变为：原子的读取变量value的值并把它赋给变量v。有了“原子的”这个形容词就意味着，在这里读取value的值的同时，当前计算机中的任何CPU都不会进行其它的针对此值的读或写操作。这样的约束是受到底层硬件的支持的。注意，虽然我们在这里使用atomic.LoadInt32函数原子的载入value的值，但是其后面的CAS操作仍然是有必要的。因为，那条赋值语句和if语句并不会被原子的执行。在它们被执行期间，CPU仍然可能进行其它的针对value的值的读或写操作。也就是说，value的值仍然有可能被并发的改变。与atomic.LoadInt32函数的功能类似的函数有atomic.LoadInt64、atomic.LoadPointer、atomic.LoadUint32、atomic.LoadUint64和atomic.LoadUintptr。\4. 存储与读取操作相对应的是写入操作。而sync/atomic包也提供了与原子的值载入函数相对应的原子的值存储函数。这些函数的名称均以“Store”为前缀。在原子的存储某个值的过程中，任何CPU都不会进行针对同一个值的读或写操作。如果我们把所有针对此值的写操作都改为原子操作，那么就不会出现针对此值的读操作因被并发的进行而读到修改了一半的值的情况了。原子的值存储操作总会成功，因为它并不会关心被操作值的旧值是什么。显然，这与前面讲到的CAS操作是有着明显的区别的。因此，我们并不能把前面展示的addValue函数中的调用atomic.CompareAndSwapInt32函数的表达式替换为对atomic.StoreInt32函数的调用表达式。函数atomic.StoreInt32会接受两个参数。第一个参数的类型是int 32类型的，其含义同样是指向被操作值的指针。而第二个参数则是int32类型的，它的值应该代表欲存储的新值。其它的同类函数也会有类似的参数声明列表。\5. 交换在sync/atomic代码包中还存在着一类函数。它们的功能与前文所讲的CAS操作和原子载入操作都有些类似。这样的功能可以被称为原子交换操作。这类函数的名称都以“Swap”为前缀。与CAS操作不同，原子交换操作不会关心被操作值的旧值。它会直接设置新值。但它又比原子载入操作多做了一步。作为交换，它会返回被操作值的旧值。此类操作比CAS操作的约束更少，同时又比原子载入操作的功能更强。以atomic.SwapInt32函数为例。它接受两个参数。第一个参数是代表了被操作值的内存地址的int32类型值，而第二个参数则被用来表示新值。注意，该函数是有结果值的。该值即是被新值替换掉的旧值。atomic.SwapInt32函数被调用后，会把第二个参数值置于第一个参数值所表示的内存地址上（即修改被操作值），并将之前在该地址上的那个值作为结果返回。其它的同类函数的声明和作用都与此类似。至此，我们快速且简要地介绍了sync/atomic代码包中的所有函数的功能和用法。这些函数都被用来对特定类型的值进行原子性的操作。如果我们想以并发安全的方式操作单一的特定类型（int32、int64、uint32、uint64、uintptr或unsafe.Pointer）的值的话，应该首先考虑使用这些函数来实现。请注意，原子的减小一些特定类型（确切地说，是uint32类型和uint64类型）的值的实现方式并不那么直观。在Go语言官方对此进行改进之前，我们应该按照他们为我们提供的那种方式来进行此类操作。\6. 应用于实际下面，我们就使用刚刚介绍的知识再次对在前面示例中创建的myDataFile类型进行改造。在myDataFile类型的第二个版本中，我们仍然使用两个互斥锁来对与roffset字段和woffset字段相关的操作进行保护。myDataFile类型的方法中的绝大多数都包含了这些操作。首先，我们来看对roffset字段的操作。在*myDataFile类型的Read方法中有这样一段代码： 123456// 读取并更新读偏移量var offset int64df.rmutex.Lock()offset = df.roffsetdf.roffset += int64(df.dataLen)df.rmutex.Unlock() 这段代码的含义是读取读偏移量的值并把它存入到局部变量中，然后增加读偏移量的值以使其它的并发的读操作能够被正确、有效的进行。为了使程序能够在并发环境下有序的对roffset字段进行操作，我们为这段代码应用了互斥锁rmutex。字段roffset和变量offset都是int64类型的。后者代表了前者的旧值。而字段roffset的新值即为其旧值与dataLen字段的值的和。实际上，这正是原子的CAS操作的适用场景。我们现在用CAS操作来实现该段代码的功能： 123456789// 读取并更新读偏移量 var offset int64 for &#123; offset = df.roffset if atomic.CompareAndSwapInt64(&amp;df.roffset, offset, (offset + int64(df.dataLen))) &#123; break &#125; &#125; 根据roffset和offset的类型，我们选用atomic.CompareAndSwapInt64来进行CAS操作。我们在调用该函数的时候传入了三个参数，分别代表了被操作值的地址、旧值和新值。如果该函数的结果值是true，那么我们就退出for循环。这时，变量offset即是我们需要的读偏移量的值。另一方面，如果该函数的结果值是false，那么就说明在从完成读取到开始更新roffset字段的值的期间内有其它的并发操作对该值进行了更改。当遇到这种情况，我们就需要再次尝试。只要尝试失败，我们就会重新读取roffset字段的值并试图对该值进行CAS操作，直到成功为止。具体的尝试次数与具体的并发环境有关。我们在前面说过，在32位计算架构的计算机上写入一个64位的整数也会存在并发安全方面的隐患。因此，我们还应该将这段代码中的offset = df.roffset语句修改为offset = atomic.LoadInt64(&amp;df.roffset)。除了这里，在*myDataFile类型的Rsn方法中也有针对roffset字段的读操作： 123df.rmutex.Lock()defer df.rmutex.Unlock()return df.roffset / int64(df.dataLen) 我们现在去掉施加在上面的锁定和解锁操作，转而使用原子操作来实现它。修改后的代码如下： 12offset := atomic.LoadInt64(&amp;df.roffset)return offset / int64(df.dataLen) 这样，我们就在依然保证相关操作的并发安全的前提下去除了对互斥锁rmutex的使用。对于字段woffset和互斥锁wmutex，我们也应该如法炮制。读者可以试着按照上面的方法修改与之相关的Write方法和Wsn方法。在修改完成之后，我们就可以把代表互斥锁的rmutex字段和wmutex字段从myDataFile类型的基本结构中去掉了。这样，该类型的基本结构会显得精简了不少。通过本次改造，我们减少了myDataFile类型及其方法对互斥锁的使用。这对该程度的性能和可伸缩性都会有一定的提升。其主要原因是，原子操作由底层硬件支持，而锁则由操作系统提供的API实现。若实现相同的功能，前者通常会更有效率。读者可以为前面展示的这三个版本的*myDataFile类型的实现编写性能测试，以验证上述观点的正确性。总之，我们要善用原子操作。因为它比锁更加简练和高效。不过，由于原子操作自身的限制，锁依然常用且重要。]]></content>
      <categories>
        <category>Golang并发</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang并发之sync.WaitGroup]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2FGolang%E5%B9%B6%E5%8F%91%E4%B9%8Bsync-WaitGroup%2F</url>
    <content type="text"><![CDATA[声明1var wg sync.WaitGroup sync.WaitGroup/ Golang内置sync包 Wg变量：该类型有三个指针方法，即Add、Done和Wait。 类型sync.WaitGroup是一个结构体类型。当一个sync.WaitGroup类型的变量被声明之后，其值中的那个计数值将会是0。 我们可以通过该值的Add方法增大或减少其中的计数值。 如下： wg.Add(1) 与wg.Add(-1)的执行效果是一致的： wg.Done() 总结: 1、使用Done方法禁忌与Add方法的一样——不要让相应的计数值变为负数。 例如，这段代码中的第5条语句会引发一个运行时恐慌： var wg sync.WaitGroup wg.Add(2) wg.Done() wg.Done() wg.Done() 2、当我们调用sync.WaitGroup类型值的Wait方法的时候，它会去检查该值中的计数值。如果这个计数值为0，那么该方法会立即返回，且不会对程序的运行产生任何影响。 但是，如果这个计数值大于0，那么该方法的调用方所属的那个Goroutine就会被阻塞。直到该计数值重新变为0之时，为此而被阻塞的所有Goroutine才会被唤醒。 代码案例1234567891011121314151617181920212223242526272829303132333435// 协调多个Goroutine的运行。假设，在我们的程序中启用了4个Goroutine，分别是G1、G2、G3和G4。其中，G2、G3和G4是由G1中的代码启用并被用于执行某些特定任务的。G1在启用这3个Goroutine之后要等待这些特定任务的完成。// 方案1（channel通道）sign := make(chan byte, 3)go func() &#123; //G2 sign &lt;- 2&#125;()go func() &#123; //G3 sign &lt;- 3&#125;()go func() &#123; //G4 sign &lt;- 4&#125;()for i := 0; i &lt; 3; i++ &#123;fmt.Printf("G%d is ended.\n", &lt;-sign)&#125;// 方案2（sync.WaitGroup）var wg sync.WaitGroupwg.Add(3)go func() &#123; //G2 wg.Done()&#125;()go func() &#123; //G3 wg.Done()&#125;()go func() &#123; //G4 wg.Done()&#125;()wg.Wait()fmt.Println("Finish") 12345678910111213141516171819202122package mainimport ( "fmt" "sync" "time")func main() &#123; var wg sync.WaitGroup for i := 0; i &lt; 5; i = i + 1 &#123; wg.Add(1) go func(n int) &#123; // defer wg.Done() defer wg.Add(-1) EchoNumber(n) &#125;(i) // n = i &#125; wg.Wait()&#125;func EchoNumber(i int) &#123; time.Sleep(3e9) fmt.Println(i)&#125;]]></content>
      <categories>
        <category>Golang并发</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo入坑-主题篇]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2FHexo%E5%85%A5%E5%9D%91-%E4%B8%BB%E9%A2%98%E7%AF%87%2F</url>
    <content type="text"></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo入坑-安装篇]]></title>
    <url>%2Fsheldon_blog%2Fpassages%2FHexo%E5%85%A5%E5%9D%91-%E5%AE%89%E8%A3%85%E7%AF%87%2F</url>
    <content type="text"><![CDATA[准备 有一个github账号，没有的话去注册一个 安装了git、node.js、npm，并了解相关基础知识 12node -vgit --version 安装了git for Mac（或者其它git客户端） 安装1. 创建github仓库​ github上新建一个名为用户名.github.io的项目，例如：sheldon-lu.github.io， 这个项目名是用来做域名用的，当然也可以去申请一个属于自己的域名，一般推荐godaddy 2. 配置SSH key免密上传不详细讲了，命令如下： 1234567891011cd ~/.ssh# 检查本机已存在的ssh密钥# 如果提示：No such file or directory 说明你是第一次使用git。ssh-keygen -t rsa -C "邮件地址"# 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key# 测试是否成功，验证命令：ssh -T git@GitHub.com## Hi cnfeat! You've successfully authenticated, but GitHub does not provide shell access.出现这个就是成功了，之后可以测试一下push是否免密上传。# 此时你可能还需要配置，这个属于全局config，对于git项目完全可以git clone下来之后进行push等等操作：git config --global user.name "liuxianan"// 你的github用户名，非昵称git config --global user.email "xxx@qq.com"// 填写你的github注册邮箱 3. Hexo安装及介绍官网： http://hexo.io github: https://github.com/hexojs/hexo 由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 安装之前先来说几个注意事项： 很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行（对于windows用户而言）； hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导； hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的； 这里给官网上的部署命令： 1234567891011mkdir &lt;Your blog&gt; # 创建blog文档文件夹npm install hexo-cli -g # 安装hexo以及hexo命令# 初始化一个blog项目，其中'blog'为你的blog名字，hexo会自动下载一些文件到这个目录，包括node_modules.hexo init blogcd blognpm installhexo server## 这两个命令是经常会用到的hexo s -g #生成并本地预览hexo d -g #生成并上传 对于mac用户，如果遇到以下报错： 123456789101112131415161718安装npm install hexo-cli -g时报错npm install hexo -gnpm WARN locking Error: EACCES, open &apos;/Users/lushenneng/.npm/_locks/hexo-4ded2cf5ea4a8daa.lock&apos;npm WARN locking at Error (native)npm WARN locking /Users/lushenneng/.npm/_locks/hexo-4ded2cf5ea4a8daa.lock failed &#123; [Error: EACCES, open &apos;/Users/lushenneng/.npm/_locks/hexo-4ded2cf5ea4a8daa.lock&apos;]npm WARN locking errno: -13,npm WARN locking code: &apos;EACCES&apos;,npm WARN locking path: &apos;/Users/lushenneng/.npm/_locks/hexo-4ded2cf5ea4a8daa.lock&apos; &#125;npm ERR! Darwin 14.0.0npm ERR! argv &quot;node&quot; &quot;/usr/bin/npm&quot; &quot;install&quot; &quot;hexo&quot; &quot;-g&quot;npm ERR! node v0.12.3npm ERR! npm v2.9.1npm ERR! Attempt to unlock /usr/lib/node_modules/hexo, which hasn&apos;t been lockednpm ERR!npm ERR! If you need help, you may report this error at:npm ERR! https://github.com/npm/npm/issuesnpm ERR! Please include the following file with any support request:npm ERR! /Users/lushenneng/blog/npm-debug.log 解决： 12345# 可以先用这个命令：sudo npm install hexo-cli -g# 如果还是报错可以用这个命令：sudo npm install --unsafe-perm --verbose -g hexo# 加上sudo一般能解决很多问题 4. START Hexo在blog目录下的_config.yml配置修改如下：(大概是在最后一行) 12345deploy: type: git repository: github: git@github.com:sheldon-lu/sheldon_blog.git branch: master 我这里不指定用的github.io这个域名是因为我用sheldon-lu.github.io作主域名，sheldon_blog作文根，当然这样的话这边hexo内设置如下：(大概在14行左右开始) 1234567# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://sheldon-lu.github.io/root: /sheldon_blog# permalink: :year/:month/:day/:title/permalink: passages/:title/permalink_defaults: 至此，就可以使用了，浏览器输入域名：https://sheldon-lu.github.io/sheldon_blog即可 1、这里要说明一下，使用 hexo d 上传至github时如果需要用到 gh-pages 的话，记得在自己github的blog项目下创建个gh-pages的分支，即可; 2、_config.yml中配置repository时一定配置的要是ssh，别弄的什么https://github之类的 参考地址：https://ngwind.github.io/2018/07/27/%E4%BD%BF%E7%94%A8gh-pages+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E9%A1%B5%E6%95%99%E7%A8%8B/]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
